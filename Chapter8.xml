<!-- Converted by db4-upgrade version 1.0 -->
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="chapter-9" label="9">
    <title>The Forms of Resource Descriptions</title>
    <info>
        <itermset>
            <indexterm zone="chapter-9">
                <primary>resource description</primary>
                <secondary>form</secondary>
            </indexterm></itermset>
        <author>
            <personname><firstname>Ryan</firstname><surname>Shaw</surname></personname>
        </author>
        <author>
            <personname><firstname>Murray</firstname><surname>Maloney</surname></personname>
        </author>

        <keywordset>
            <keyword>form</keyword>
            <keyword>abstract models</keyword>
            <keyword>metamodels</keyword>
            <keyword>controlled vocabulary</keyword>
            <keyword>data structures</keyword>
            <keyword>MESH</keyword>
            <keyword>constraints</keyword>
            <keyword>JSON</keyword>
            <keyword>XML Information Set</keyword>
            <keyword>Semantic Web</keyword>
            <keyword>RDF</keyword>
            <keyword>mixed content</keyword>
            <keyword>triples</keyword>
            <keyword>predicate</keyword>
            <keyword>subject</keyword>
            <keyword>object</keyword>
            <keyword>schemas</keyword>
            <keyword>writing systems</keyword>
            <keyword>syntax</keyword>
            <keyword>grammar</keyword>
            <keyword>encoding scheme</keyword>
            <keyword>notation</keyword>
            <keyword>transclusion</keyword>
        </keywordset>
    </info>

    <!--              -->
    <section xml:id="section-9.1" label="9.1">
        <title>Introduction</title>
        <info>
            <itermset>
                <indexterm zone="section-9.1">
                    <primary>resource description</primary>
                    <secondary>form</secondary>
                    <tertiary>introduction</tertiary>
                </indexterm></itermset>
        </info>
        
        <sidebar xml:id="ch08-stats" userlevel="Editor" condition="epub3 print" role="statistics">
            <?dbhtml sidebar-width="60%"?>
            <?dbhtml float-type="right"?>
            <?dbfo sidebar-width="60%"?>
            <?dbfo float-type="inside"?>
            <informalfigure xml:id="inf-fig-ch08-stats">
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="Visualisations/ch08-stats.png" format="JPG"/>
                    </imageobject>
                    <textobject>
                        <phrase role="ALT descriptive">This graphic describes the content breakdown
                            of the chapter. A wheel with colored segments depicts core content
                            versus disciplinary content in this chapter, and a bar chart illustrates
                            the disciplinary content distribution. In this chapter, Computing notes
                            predominate, followed far behind by Linguistics, Web CogSci, LIS, and
                            Business. There are no Archives, IA, Law, Museums, or Philosophy notes
                            in this chapter.</phrase>
                    </textobject>
                </mediaobject>
            </informalfigure>
        </sidebar>
        <para audience="CORE" xml:id="para-bj2_q4r_lr"><phrase role="statement principle">Throughout
                this book, we have emphasized the importance of separately considering fundamental
                organizing principles, application-specific concepts, and details of
                implementation.</phrase> The three-tier architecture we introduced in <xref
                linkend="section-1.6" xrefstyle="short"/> is one way to conceptualize this
            separation. In <xref linkend="section-6.7" xrefstyle="short"/>, we contrasted the
            implementation-focused perspective for analyzing relationships with other perspectives
            that focus on the meaning and abstract structure of relationships. In this chapter, we
            present this contrast between conceptualization and implementation in terms of
            separating the <emphasis>content</emphasis> and <emphasis><glossterm
                    linkend="gloss_form">form</glossterm></emphasis> of resource
            descriptions.</para>
        <para audience="CORE" xml:id="para-h42_q4r_lr">In the previous chapters, we have considered
            principles and concepts of organizing in many different contexts, ranging from personal
            organizing systems to cultural and institutional ones. We have noted that some
            organizing systems have limited scope and expected lifetime, such as a task-oriented
            personal organizing system like a shopping list. Other organizing systems support broad
            uses that rely on standard categories developed through rigorous processes, like a
            product catalog.</para>
        <para audience="CORE" xml:id="para-kt2_q4r_lr">By this point you should have a good sense of
            the various conceptual issues you need to consider when deciding how to describe a
            resource in order to meet the goals of your organizing system. Considering those issues
            will give you some sense of what the content of your descriptions should be. In order to
            focus on the conceptual issues, we have deferred discussion of specific implementation
            issues. Implementation involves choosing the specific form of your descriptions, and
            that is the topic of this chapter.</para>
        <para audience="CORE" xml:id="para-nx2_q4r_lr"><phrase role="principle statement">We can
                approach the problem of how to form resource descriptions from two perspectives:
                structuring and writing.</phrase> From one perspective, resource descriptions are
            things that are <emphasis>used</emphasis> by both people and computational agents. From
            this perspective, choosing the form of resource descriptions is a kind of design. This
            is easy to see for certain kinds of resource descriptions, notably signs and maps found
            in physical environments like airport terminals, public libraries, and malls. In these
            spaces, resource descriptions are quite literally designed to help people orient
            themselves and find their way. But any kind of resource description, not just those
            embedded in the built environment, can be viewed as a designed object. Designing an
            object involves making decisions about how it should be structured so that it can best
            be used for its intended purpose. From a design perspective, choosing the form of a
            resource description means making decisions about its
            <emphasis>structure</emphasis>.</para>
        
        <para audience="CORE" role="contrast" xml:id="para-hbf_q4r_lr">In <xref
                linkend="section-6.5" xrefstyle="short"/>, we took a structural perspective on
            resources and the relationships among them. In this chapter, we will take a structural
            perspective on resource <emphasis>descriptions</emphasis>. The difference is subtle but
            important. A structural perspective on resource <emphasis>relationships</emphasis>
            focuses on how people or computational processes associate, arrange, and connect those
            resources. A structural perspective on resource <emphasis>descriptions</emphasis>
            focuses on how those associations, arrangements, and connections are explicitly
            represented or implemented in the descriptions we create. Mismatches between the
            structure imposed on the resources being organized and the structure of the descriptions
            used to implement that organization could result in an organizing system that is
            complex, inefficient, and difficult to maintain, as you will see in our first example
                <phrase role="parenthetical">(<xref linkend="example-9-1" xrefstyle="short"
                />)</phrase>.</para>
        <para audience="CORE" xml:id="para-z2f_q4r_lr">The structures of resource descriptions
            enable or inhibit particular ways of interacting with those descriptions, just as the
            descriptions themselves enable or inhibit particular ways of interacting with the
            described resources. <phrase role="parenthetical">(See <xref linkend="section-3.4"/>,
                and <xref linkend="chapter-10"/>)</phrase> Keep in mind that resource descriptions
            are themselves information resources, so much of what we will say in this chapter is
            applicable to the structures and forms of information resources in general. Put another
            way, the structure and form of information resources informs the design of resource
            descriptions.</para>
        <para audience="CORE" xml:id="para-zhf_q4r_lr">From another perspective, creating resource
            descriptions is a kind of writing. I may describe something to you orally, but such a
            description might not be very useful to an organizing system unless it were transcribed.
            Organizing systems need persistent descriptions, and that means they need to be written.
            In that sense, choosing the form of a resource description means making decisions about
                <emphasis>notation</emphasis> and <emphasis>syntax</emphasis>.</para>
        <note userlevel="Editor" xml:id="note-ch8-Editor-kbh_5bs_lr">
            <title>Editors' Note</title>
            <para xml:id="para-zkf_q4r_lr">Bob, this is an opportunity to mention ancient oral
                tradition, including native American, and how these resources are being captured by
                modern chroniclers. The stories are recorded and transcribed in distinct native
                languages and sometimes translated into English. This is enabling a new generation
                to hear, learn and re-tell ancient legends of their history and culture.</para>
        </note>
        <para audience="CORE" xml:id="para-xnf_q4r_lr">Modern Western culture tends to make a sharp
            distinction between designing and writing, but there are areas where this distinction
            breaks down, and the creation of resource descriptions in organizing systems is one of
            them. In the following sections, we will use designing and writing as two lenses for
            looking at the problem of how to choose the form of resource descriptions. Specifically,
            we will examine the spectrum of options we have for structuring descriptions, and the
            kinds of syntaxes we have for writing those descriptions.</para>
    </section>
    <!--              -->
    <section xml:id="section-9.2" label="9.2">
        <title>Structuring Descriptions</title>
        <info>
            <itermset>
                <indexterm zone="section-9.2">
                    <primary>structuring</primary>
                    <secondary>description</secondary>
                </indexterm>
                <indexterm zone="section-9.2">
                    <primary>resource description</primary>
                    <secondary>structuring</secondary>
                </indexterm></itermset>
        </info>

        <para audience="CORE" xml:id="para-zqf_q4r_lr"><phrase role="principle statement">Choosing
                how to structure resource descriptions is a matter of making principled and
                purposeful design decisions in order to solve specific problems, serve specific
                purposes, or bring about some desirable property in the descriptions.</phrase> Most
            of these decisions are specific to a <emphasis>domain</emphasis>: the particular context
            of application for the organizing system being designed and the kinds of interactions
            with resources it will enable. Making these kinds of context-specific decisions results
            in a model of that domain.<phrase role="parenthetical"> (See <xref
                    linkend="section-5.3.1.2"/>.)</phrase></para>
        <para audience="CORE" xml:id="para-u5f_q4r_lr"><info><itermset>
            <indexterm significance="preferred" zone="def_metamodels">
                <primary>metamodel</primary>
            </indexterm><indexterm zone="def_metamodels">
                <primary>language</primary>
                <secondary>metamodels</secondary>
            </indexterm></itermset>
        </info>Over time, many people have built similar
            kinds of descriptions. They have had similar purposes, desired similar properties, and
            faced similar problems. Unsurprisingly, they have converged on some of the same
            decisions. <phrase role="definition" xml:id="def_metamodels">When common sets of design
                decisions can be identified that are not specific to any one domain, they often
                become systematized in textbooks and in design practices, and may eventually be
                designed into standard formats and architectures for creating organizing systems.
                These formally recognized sets of design decisions are known as <firstterm
                    xml:id="first_abstract_models" linkend="gloss_abstract_models">abstract
                    models</firstterm> or <glossterm xreflabel="metamodels"
                    xml:id="first_metamodels">metamodels</glossterm>. <glossterm
                    xml:id="term_metamodels">Metamodels</glossterm> describe structures commonly
                found in resource descriptions and other information resources, regardless of the
                specific domain.</phrase> While any designer of an organizing system will usually
            create a model of her specific domain, she usually will not create an entirely new
            metamodel but will instead make choices from among the metamodels that have been
            formally recognized and incorporated into existing standards. The resulting model is
            sometimes called a <quote>domain-specific language.</quote> Reusing standard metamodels
            can bring great economical advantages, as developers can reuse tools designed for and
            knowledge about these metamodels, rather than having to start from scratch.</para>
        <para audience="CORE" xml:id="para-xyf_q4r_lr">In the following sections, we examine some
            common kinds of structures used as the basis for metamodels. But first, we consider a
            concrete example of how the structure of resource descriptions supports or inhibits
            particular uses. As we explained in <xref linkend="chapter-1" xrefstyle="short"/>, the
            concept of a resource de-emphasizes the differences between physical and digital things
            in favor of focusing on how things, in general, are used to support goal-oriented
            activity. Different kinds of books can be treated as information resources regardless of
            the particular mix of tangible and intangible properties they may have. Since resource
            descriptions are also information resources, we can similarly consider how their
            structures support particular uses, independent of whether they are physical, digital,
            or a mix of both.</para>
        <figure xml:id="figure-9-1" floatstyle="true" label="9.1">
            <title>A Batten Card.</title>

            <mediaobject xml:id="figure-9-1a">
                <imageobject>
                    <imagedata fileref="figs/Figure-8.1.jpg" format="JPG"/>
                </imageobject>
                <textobject>
                    <phrase role="ALT descriptive">An example of a punch card.</phrase>
                </textobject>
                <caption>
                    <para audience="CORE" xml:id="para-a3g_q4r_lr"><phrase role="caption">An example
                            of a punch card used by Batten to describe a particular patent in a
                            patent collection. Each card represented an individual description term,
                            and each punch position on a card represented a particular
                            patent.</phrase></para>
                </caption>
                <!--
                <imageobject role="web">
                    <imagedata fileref="figs/web/Ch8-Figure-1.png" format="PNG"/>
                </imageobject>
                -->
            </mediaobject>
        </figure>
        <para audience="CORE" xml:id="para-hcg_q4r_lr"><info>
                <itermset>
                    <indexterm zone="para-hcg_q4r_lr" userlevel="Professional Graduate">
                        <primary>Batten, W. E.</primary>
                    </indexterm>
                </itermset>
            </info>During World War II, a British chemist named <personname><firstname>W.
                    E.</firstname><surname>Batten</surname></personname> developed a system for
            organizing patents.<footnote xml:id="endnote-439" label="516" audience="Computing">
                <para audience="Computing" xml:id="para-cfg_q4r_lr"><info>
                        <itermset>
                            <indexterm audience="Markup" zone="endnote-439">
                                <primary>endnote</primary>
                                <secondary>Computing</secondary>
                            </indexterm>
                            <indexterm zone="endnote-439">
                                <primary>computing</primary>
                                <secondary>Batten cards</secondary>
                            </indexterm>
                        </itermset>
                    </info>This discussion of Batten’s cards is based on <citation
                        xml:id="cite_Lancaster1968" linkend="Lancaster1968">(Lancaster 1968, pages
                        28-32)</citation>. Batten’s own explanation is in <citation
                        xml:id="cite_Batten1951" linkend="Batten1951">(Batten
                    1951)</citation>.</para>
            </footnote> The system consisted of a language for describing the product, process, use,
            and apparatus of a patent, and a way of using punched cards to record these
            descriptions. Batten used cards printed with matrices of 800 positions (see <xref
                linkend="figure-9-1" xrefstyle="select: label"/>). Each card represented a specific
            value from the vocabulary of the description language, and each position corresponded to
            a particular patent. To describe patent <superscript>#</superscript>256 as covering
                <emphasis>extrusion of polythene to produce cable coverings</emphasis>, one would
            first select the cards for the values <emphasis>polythene</emphasis>,
                <emphasis>extrusion</emphasis>, and <emphasis>cable coverings</emphasis>, and then
            punch each card at the 256<superscript>th</superscript> position. The description of
            patent <superscript>#</superscript>256 would thus extend over these three cards.</para>
        <para audience="CORE" xml:id="para-ykg_q4r_lr">The advantage of this structure is that to
            find patents covering <emphasis>extrusion of polythene</emphasis> (for any purpose), one
            needs only to select the two cards corresponding to those values, lay one on top of the
            other, and hold them up to a light. Light will shine through wherever there is a
            position corresponding to a patent described using those values. Patents meeting a
            certain description are easily found due to the structure of the cards designed to
            describe the patents.</para>
        <sidebar xml:id="sidebar-PunchcardMachine" audience="CORE LIS Computing IA">
            <?dbhtml sidebar-width="50%"?>
            <?dbhtml float-type="right"?>
            <?dbfo sidebar-width="55%"?>
            <?dbfo float-type="inside"?>
            <title>Punchcard Machine</title>
            <info>
                <itermset>
                    <indexterm zone="sidebar-PunchcardMachine" condition="print"
                        userlevel="Professional Graduate">
                        <primary>sidebar</primary>
                        <secondary>Punchcard Machine</secondary>
                    </indexterm>
                    <indexterm zone="sidebar-PunchcardMachine" userlevel="Professional Graduate">
                        <primary>Punchcard Machine</primary>
                    </indexterm>
                    <indexterm zone="sidebar-PunchcardMachine">
                        <primary>resource description</primary>
                    </indexterm>
                </itermset>
            </info>
            <informalfigure xml:id="PICTURE-S9.2-PunchcardMachine" xreflabel="Punchcard Machine">
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="Pictures/8.2-PunchcardMachine-OK.JPG" format="JPG"/>
                    </imageobject>
                    <textobject>
                        <phrase role="ALT descriptive">A punchcard machine.</phrase>
                    </textobject>
                    <caption>
                        <para audience="CORE" xml:id="para-u5g_q4r_lr"><phrase role="caption"
                                >Punchcards were an important information input and storage medium
                                for decades, even before the invention of computers. The Hollerith
                                keyboard punch was used to transcribe the information collected in
                                the <date>1890</date> US census. The template being used in this
                                photo is for recording information about a farm. The punch cards
                                were tabulated by electromechanical machines. A merger of four
                                tabulating machine companies in <date>1911</date> created a company
                                whose current name is IBM.</phrase></para>
                        <para audience="CORE" xml:id="para-nxg_q4r_lr">This keyboard punch machine
                            is in the collection of the Computer History Museum in Mountain View,
                            California.</para>
                        <para audience="CORE" xml:id="para-n1h_q4r_lr"><phrase role="credit">(Photo
                                by R. Glushko.)</phrase></para>
                    </caption>
                </mediaobject>
            </informalfigure>
        </sidebar>
        <para audience="CORE" xml:id="para-ung_q4r_lr">Of course, this system has clear
            disadvantages as well. Finding the concepts associated with a particular patent is
            tedious, because every card must be inspected. Adding a new patent is relatively easy as
            long as there is an index that allows the cards for specific concepts to be located
            quickly. However, once the cards run out of space for punching holes, the whole set of
            cards must be duplicated to accommodate more patents: a very expensive operation. Adding
            new concepts is potentially easy: simply add a new card. But if we want to be able to
            find existing patents using the new concept, all the existing patents would have to be
            re-examined to determine whether their positions on the new card should be punched: also
            an expensive operation.</para>
        <para audience="CORE" xml:id="para-wqg_q4r_lr"><info><itermset>
            <indexterm zone="para-wqg_q4r_lr">
                <primary>costs</primary>
                <secondary>efficiency</secondary>
            </indexterm></itermset>
        </info>The structure of Batten’s cards supported rapid selection of resources given
            a partial description. The kinds of structures we will examine in the following sections
            are not quite so elaborate as Batten’s cards. But like the cards, each kind of structure
            supports more efficient mechanical execution of certain operations, at the cost of less
            efficient execution of others.</para>
        <!--              -->
        <?need 10cm ?>
        
        <section xml:id="section-9.2.1" label="9.2.1">
            <title>Kinds of Structures</title>
            <info>
                <itermset>
                    <indexterm zone="section-9.2.1">
                        <primary>structures</primary>
                        <secondary>kinds</secondary>
                    </indexterm>
                    <indexterm zone="section-9.2.1">
                        <primary>resource description</primary>
                        <secondary>structures</secondary>
                    </indexterm></itermset>
        </info>
            
            <para audience="CORE IA" xml:id="para-fdh_q4r_lr"><info><itermset>
                <indexterm zone="para-fdh_q4r_lr">
                    <primary>abstraction</primary>
                    <secondary>related structures</secondary>
                </indexterm></itermset>
        </info><phrase role="statement">Sets, lists, dictionaries, trees, and graphs
                    are kinds of structures that can be used to form resource descriptions.</phrase>
                As we shall see, each of these kinds is actually a family of related structures.
                These structures are <emphasis>abstractions</emphasis>: they describe formal
                structural properties in a general way, rather than specifying an exact physical or
                textual form. Abstractions are useful because they help us to see common properties
                shared by different specific ways of organizing information. By focusing on these
                common properties, we can more easily reason about the operations that different
                forms support and the affordances that they provide, without being distracted by
                less relevant details.</para>
            <!--              -->
            <section xml:id="section-9.2.1.1" label="9.2.1.1">
                <title>Blobs</title>
                <info>
                    <itermset>
                        <indexterm zone="section-9.2.1.1">
                            <primary>resource description</primary>
                            <secondary>structures</secondary>
                            <tertiary>blobs</tertiary>
                        </indexterm>
                        <indexterm zone="section-9.2.1.1">
                            <primary>blobs</primary>
                        </indexterm></itermset>
        </info>

                <para audience="CORE" xml:id="para-fgh_q4r_lr"><phrase role="principle statement"
                        >The simplest kind of structure is no structure at all.</phrase> Consider
                    the following description of a book: <emphasis>Sebald’s novel uses a walking
                        tour in East Anglia to meditate on links between past and present, East and
                        West.</emphasis><footnote xml:id="endnote-440" label="517"
                        audience="Linguistics">
                        <para audience="Linguistics" xml:id="para-z3h_q4r_lr"><info>
                                <itermset>
                                    <indexterm audience="Markup" zone="endnote-440">
                                        <primary>endnote</primary>
                                        <secondary>Linguistics</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-440">
                                        <primary>linguistics</primary>
                                    </indexterm>
                                </itermset>
                            </info><citation xml:id="cite_Silman1998" linkend="Silman1998">(Silman
                                1998)</citation>. <citation xml:id="cite_Sebald1995"
                                linkend="Sebald1995">(Sebald 1995)</citation>.</para>
                    </footnote> This description is an unstructured text expression with no clearly
                    defined internal parts, and we can consider it to be a <firstterm
                        linkend="gloss_blob" xml:id="first_blob">blob</firstterm>. Or, more
                    precisely, it has structure, but that structure is the underlying grammatical
                    structure of the English language, and none of that grammatical structure is
                    explicitly represented in a surface structure when the sentence is expressed. As
                    readers of English we can interpret the sentence as a description of the subject
                    of the book, but to do this mechanically is difficult.<footnote
                        xml:id="endnote-441" label="518" audience="Linguistics">
                        <para audience="Linguistics" xml:id="para-olh_q4r_lr"><info>
                                <itermset>
                                    <indexterm audience="Markup" zone="endnote-441">
                                        <primary>endnote</primary>
                                        <secondary>Linguistics</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-441">
                                        <primary>linguistics</primary>
                                        <secondary>diagramming sentences</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-441">
                                        <primary>diagramming sentences</primary>
                                    </indexterm>
                                    <indexterm zone="endnote-441">
                                        <primary>A Practical Grammar</primary>
                                    </indexterm>
                                </itermset>
                            </info>The technique of diagramming sentences was invented in the
                                <date>mid-19th century</date> by Stephen W. Clark, a New York
                            schoolmaster; <citation xml:id="cite_Clark2010" linkend="Clark2010"
                                >(Clark2010)</citation> is an exact reprinting of a nearly 100 year
                            old edition of his book <citetitle xml:id="cite_Clark1868"
                                linkend="Clark1868" pubwork="book">A Practical Grammar.</citetitle>
                            A recent tribute to Clark is <citation xml:id="cite_Florey2012"
                                linkend="Florey2012">(Florey 2012)</citation>.</para>
                    </footnote> On the other hand, such a written description is relatively easy to
                    create, as the describer can simply use natural language.</para>
                <para audience="CORE" xml:id="para-f4h_q4r_lr">A blob need not be a blob of text. It
                    could be a photograph of a resource, or a recording of a spoken description of a
                    resource. Like blobs of text, blobs of pixels or sound have underlying structure
                    that any person with normal vision or hearing can understand easily.<footnote
                        xml:id="endnote-442" label="519" audience="CogSci">
                        <para audience="CogSci" xml:id="para-erh_q4r_lr"><info>
                                <itermset>
                                    <indexterm audience="Markup" zone="endnote-442">
                                        <primary>endnote</primary>
                                        <secondary>CogSci</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-442">
                                        <primary>neural computation and knowledge</primary>
                                    </indexterm>
                                    <indexterm zone="endnote-442">
                                        <primary>human perceptual and cognitive systems</primary>
                                    </indexterm>
                                    <indexterm zone="endnote-442">
                                        <primary>cognitive science</primary>
                                        <secondary>neural computation</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-442">
                                        <primary>computational</primary>
                                        <secondary>agents</secondary>
                                    </indexterm>
                                </itermset>
                            </info>It is easy to underestimate the incredible power of the human
                            perceptual and cognitive systems to apply neural computation and
                            knowledge to enable vision and hearing to seem automatic. Computers are
                            getting better at extracting features from visual and auditory signals
                            to identify and classify inputs, but our point here is that none of
                            these features are explicitly represented in the input
                                <quote>blob</quote> or <quote>stream.</quote></para>
                    </footnote> But we can treat these blobs as unstructured, because none of the
                    underlying structure in the visual or auditory input is explicit, and we are
                    concerned with the ways that the structures of resource descriptions support or
                    inhibit mechanical or computational operations.<footnote xml:id="endnote-443"
                        label="520" audience="Computing">
                        <para audience="Computing" xml:id="para-p5h_q4r_lr"><info>
                                <itermset>
                                    <indexterm audience="Markup" zone="endnote-443">
                                        <primary>endnote</primary>
                                        <secondary>Computing</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-443">
                                        <primary>resource description</primary>
                                        <secondary>oral</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-443">
                                        <primary>oral description</primary>
                                    </indexterm>
                                    <indexterm zone="endnote-443">
                                        <primary>computing</primary>
                                        <secondary>audio description</secondary>
                                    </indexterm>
                                </itermset>
                            </info>As we commented earlier, an oral description of a resource may
                            not be especially useful in an organizing system because computers
                            cannot easily understand it. On the other hand, there are many contexts
                            in which an oral description would be especially useful, such as in a
                            guided tour of a museum where visitors can use audio headsets.</para>
                    </footnote></para>
            </section>
            <!--              -->
            <section xml:id="section-9.2.1.2" label="9.2.1.2">
                <title>Sets</title>
                <info>
                    <itermset>
                        <indexterm zone="section-9.2.1.2">
                            <primary>resource description</primary>
                            <secondary>structures</secondary>
                            <tertiary>sets</tertiary>
                        </indexterm></itermset>
        </info>

                <para audience="CORE" xml:id="para-pxh_q4r_lr"><info>
                        <itermset>
                            <indexterm significance="preferred" zone="def_set">
                                <primary>set</primary>
                            </indexterm>
                            <indexterm zone="def_set">
                                <primary>data structures</primary>
                                <secondary>sets</secondary>
                            </indexterm>
                        </itermset>
                    </info><phrase role="definition" xml:id="def_set">The simplest way to structure
                        a description is to give it parts and treat them as a <glossterm
                            xml:id="term_set">set</glossterm>.</phrase> For example, the description
                    of Sebald’s novel might be reformulated as a set of terms:
                        <emphasis>Sebald</emphasis>, <emphasis>novel, East Anglia, walking,
                        history</emphasis>. Doing this has lost much of the meaning, but something
                    has been gained: we now can easily distinguish <emphasis>Sebald</emphasis> and
                        <emphasis>walking</emphasis> as separate items in the description.<footnote
                        xml:id="endnote-444" label="521" audience="LIS">
                        <para audience="LIS" xml:id="para-l13_q4r_lr"><info>
                                <itermset>
                                    <indexterm audience="Markup" zone="endnote-444">
                                        <primary>endnote</primary>
                                        <secondary>LIS</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-444">
                                        <primary>grammar</primary>
                                        <secondary>invisible structure</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-444">
                                        <primary>library science</primary>
                                        <secondary>invisible structure</secondary>
                                    </indexterm>
                                </itermset>
                            </info>What was lost was the previously invisible structure provided by
                            the grammar, which made us assign roles to each of these terms to create
                            a semantic interpretation.</para>
                    </footnote> This makes it easier to find, for example, all the descriptions that
                    include the term <emphasis>walking</emphasis>. (Note that this is different from
                    simply searching through blob-of-text descriptions for the word
                        <emphasis>walking</emphasis>. When treated as a set, the description
                        <emphasis>Fiji, fire walking, memoir</emphasis> does not include the term
                        <emphasis>walking</emphasis>, though it does include the term <emphasis>fire
                        walking</emphasis>.)</para>
                <para audience="CORE" xml:id="para-hd3_q4r_lr"><phrase role="principle statement"
                            ><glossterm linkend="gloss_set">Sets</glossterm> make it easy to find
                        intersections among descriptions.</phrase>
                    <glossterm linkend="gloss_set">Sets</glossterm> are also easy to create. In
                        <xref linkend="section-8.1.2" xrefstyle="short"/> we looked at
                        <quote>folksonomies,</quote> organizing systems in which non-professional
                    users create resource descriptions. In these systems, descriptions are
                    structured as <glossterm linkend="gloss_set">sets</glossterm> of
                        <quote>tags.</quote> To find resources, users can specify a <glossterm
                        linkend="gloss_set">set</glossterm> of tags to obtain resources having
                    descriptions that intersect at those tags. This is more valuable if the tags
                    come from a <glossterm linkend="gloss_controlled_vocabulary">controlled
                        vocabulary</glossterm>, making intersections more likely. But enforcing
                    vocabulary control adds complexity to the description process, so a balance must
                    be struck between maximizing potential intersections and making description as
                    simple as practical.<footnote xml:id="endnote-445" label="522"
                        audience="Computing">
                        <para audience="Computing" xml:id="para-gg3_q4r_lr"><info>
                                <itermset>
                                    <indexterm audience="Markup" zone="endnote-445">
                                        <primary>endnote</primary>
                                        <secondary>Computing</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-445">
                                        <primary>simple as practical</primary>
                                    </indexterm>
                                    <indexterm zone="endnote-445">
                                        <primary>computing</primary>
                                        <secondary>simple as practical</secondary>
                                    </indexterm>
                                </itermset>
                            </info>It is rarely practical to make things as simple as possible.
                            According to Einstein, we should endeavor to <quote>Make everything as
                                simple as possible, but not simpler.</quote></para>
                    </footnote></para>
                <para audience="CORE" xml:id="para-aj3_q4r_lr"><info><itermset>
                    <indexterm significance="preferred"
                        zone="def_constraint">
                        <primary>constraints</primary>
                    </indexterm><indexterm zone="def_constraint">
                        <primary>language</primary>
                        <secondary>schema</secondary>
                        <tertiary>constraint</tertiary>
                    </indexterm></itermset>
        </info><phrase role="definition" xml:id="def_constraint">A <glossterm
                            linkend="gloss_set">set</glossterm> is a type or class of structure. We
                        can refine the definition of different kinds of sets by introducing
                            <glossterm xml:id="term_constraint">constraints</glossterm>. For
                        example, we might introduce the constraint that a given set has a maximum
                        number of items. Or we might constrain a set to always have the same number
                        of items, giving us a fixed-size set. We can also remove constraints. Sets
                        do not contain duplicate items (think of a tagging system in which it does
                        not make sense to assign the same tag more than once to the same resource).
                        If we remove this <glossterm linkend="gloss_uniqueness_principle"
                            >uniqueness</glossterm> constraint, we have a different structure known
                        as a <quote>bag</quote> or <quote>multiset.</quote></phrase></para>
            </section>
            <!--              -->
            <section xml:id="section-9.2.1.3" label="9.2.1.3">
                <title>Lists</title>
                <info>
                    <itermset>
                        <indexterm zone="section-9.2.1.3">
                            <primary>resource description</primary>
                            <secondary>structures</secondary>
                            <tertiary>lists</tertiary>
                        </indexterm></itermset>
        </info>

                <para audience="CORE" xml:id="para-xl3_q4r_lr"><info><itermset>
                    <indexterm significance="preferred"
                        zone="def_list">
                        <primary>list</primary>
                    </indexterm><indexterm zone="def_list">
                        <primary>data structures</primary>
                        <secondary>list</secondary>
                    </indexterm><indexterm zone="def_list">
                        <primary>constraints</primary>
                        <secondary>data types and values</secondary>
                    </indexterm></itermset>
        </info>Constraints are what distinguish lists from sets. <phrase
                        role="definition" xml:id="def_list">A <glossterm xreflabel="list"
                            xml:id="term_list">list</glossterm>, like a <glossterm
                            linkend="gloss_set">set</glossterm>, is a collection of items with an
                        additional constraint: their items are ordered.</phrase> If we were
                    designing a tagging system in which it was important that the order of the tags
                    be maintained, we would want to use lists, not sets. Unlike sets, <glossterm
                        linkend="gloss_list">lists</glossterm> may contain duplicate items. In a
                        <glossterm linkend="gloss_list">list</glossterm>, two items that are
                    otherwise the same can be distinguished by their position in the ordering, but
                    in a set this is not possible. For example, we might want to organize the tags
                    assigned to a resource, listing the most used tag first, the least frequently
                    used last, and the rest according to their frequency of use.</para>
                <para audience="CORE" xml:id="para-s43_q4r_lr">Again, we can introduce constraints
                    to refine the definition of different kinds of <glossterm linkend="gloss_list"
                        >lists</glossterm>, such as fixed-length lists. If we constrain a list to
                    contain only items that are themselves lists, and further specify that these
                    contained lists do not themselves contains lists, then we have a
                        <emphasis>table</emphasis> (a list of lists of items). A spreadsheet is a
                    list of lists.</para>
                
                <note userlevel="Editor" xml:id="note-ch8-Editor-fgh_5bs_lr">
                    <title>Editors' Note</title>
                    <para xml:id="para-rr3_q4r_lr">This last bit seems to be jumping ahead of
                        itself. Dictionaries are next.</para>
                    <para xml:id="para-l53_q4r_lr">Bob, Ian suggests: an example to illustrate this
                        would be helpful also ... it’s pretty abstract.</para>
                </note>
                
                
                
            </section>
            <!--              -->
            <?dbfo clear ?>
            <?need 7.5cm ?>
            
            <section xml:id="section-9.2.1.4" label="9.2.1.4">
                <title>Dictionaries</title>
                <info>
                    <itermset>
                        <indexterm zone="section-9.2.1.4">
                            <primary>resource description</primary>
                            <secondary>structures</secondary>
                            <tertiary>dictionaries</tertiary>
                        </indexterm>
                        <indexterm zone="section-9.2.1.4">
                            <primary>dictionary</primary>
                        </indexterm></itermset>
        </info>

                <para audience="CORE" xml:id="para-kx3_q4r_lr">One major limitation of <glossterm
                        linkend="gloss_list">lists</glossterm> and <glossterm linkend="gloss_set"
                        >sets</glossterm> is that, although items can be individually addressed,
                    there is no way to distinguish the items except by comparing their values (or,
                    in a list, their positions in the ordering). In a set of terms like
                        <emphasis>Sebald, novel, East Anglia, walking, history</emphasis>, for
                    example, one cannot easily tell that <emphasis>Sebald</emphasis> refers to the
                    author of the book while <emphasis>East Anglia</emphasis> and
                        <emphasis>walking</emphasis> refer to what it is about. One way of
                    addressing this problem is to break each item in a set into two parts: a
                        <glossterm linkend="gloss_property" xreflabel="property"
                        >property</glossterm> and a <glossterm linkend="gloss_value"
                        xreflabel="value">value</glossterm>. So, for example, our simple set of tags
                    might become <emphasis>author: Sebald, type: novel, subject: East Anglia,
                        subject: walking, subject: history</emphasis>. Now we can say that
                        <emphasis>author</emphasis>, <emphasis>type</emphasis>, and
                        <emphasis>subject</emphasis> are the properties, and the original items in
                    the set are the values.</para>
                
                <variablelist revisionflag="added">
                    <varlistentry>
                        <term>author</term>
                        <listitem>
                            <para xml:id="para-i1j_q4r_lr">Sebald</para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>type</term>
                        <listitem>
                            <para xml:id="para-bdj_q4r_lr">novel</para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>subject1</term>
                        <listitem>
                            <para xml:id="para-agj_q4r_lr">East Anglia</para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>subject2</term>
                        <listitem>
                            <para xml:id="para-v3j_q4r_lr">walking</para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>subject3</term>
                        <listitem>
                            <para xml:id="para-vlj_q4r_lr">history</para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para audience="CORE IA" xml:id="para-o4j_q4r_lr"><info>
                        <itermset>
                            <indexterm significance="preferred" zone="def_dictionary">
                                <primary>dictionary</primary>
                            </indexterm>
                            <indexterm zone="def_dictionary">
                                <primary>data structures</primary>
                                <secondary>dictionary</secondary>
                            </indexterm>
                        </itermset>
                    </info>This kind of structure is called a <firstterm linkend="gloss_dictionary"
                        xreflabel="dictionary">dictionary</firstterm>, a <glossterm
                        linkend="gloss_map" xreflabel="map">map</glossterm> or an <glossterm
                        linkend="gloss_associative_array" xreflabel="associative array">associative
                        array</glossterm>. <phrase xml:id="def_dictionary_structure"
                        role="definition">A <glossterm xml:id="term_dictionary"
                            >dictionary</glossterm> is a set of property-value pairs or entries. It
                        is a set of entries, not a list of entries, because the pairs are not
                        ordered and because each entry must have a unique key.</phrase><footnote
                        xml:id="endnote-446" label="523" audience="Computing">
                        <para audience="Computing" xml:id="para-qrj_q4r_lr"><info>
                                <itermset>
                                    <indexterm audience="Markup" zone="endnote-446">
                                        <primary>endnote</primary>
                                        <secondary>Computing</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-446">
                                        <primary>single value constraint</primary>
                                    </indexterm>
                                    <indexterm zone="endnote-446">
                                        <primary>constraints</primary>
                                        <secondary>data types and values</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-446">
                                        <primary>computing</primary>
                                        <secondary>value constraints</secondary>
                                    </indexterm>
                                </itermset>
                            </info>This structural metamodel only allows one value for each
                            property, which means it would not work for books with multiple authors
                            or that discuss multiple subjects.</para>
                    </footnote>
                    <phrase role="definition" xml:id="def_dictionary">Note that this specialized
                        meaning of <glossterm linkend="gloss_dictionary">dictionary</glossterm> is
                        different from the more common meaning of <quote>dictionary</quote> as an
                        alphabetized list of terms accompanied by sentences that define
                        them.</phrase> The two meanings are related, however. Like a
                        <quote>real</quote> dictionary, a <glossterm linkend="gloss_dictionary"
                        >dictionary</glossterm> structure allows us to easily find the value (such
                    as a definition) associated with a particular property or
                        <emphasis>key</emphasis> (such as a word). But unlike a real dictionary,
                    which orders its keys alphabetically, a <glossterm linkend="gloss_dictionary"
                        >dictionary</glossterm> structure does not specify an order for its
                        keys.<footnote xml:id="endnote-447" label="524" audience="LIS">
                        <para audience="LIS" xml:id="para-p5j_q4r_lr"><info>
                                <itermset>
                                    <indexterm audience="Markup" zone="endnote-447">
                                        <primary>endnote</primary>
                                        <secondary>LIS</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-447">
                                        <primary>dictionary</primary>
                                        <secondary>reverse lookup</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-447">
                                        <primary>library science</primary>
                                        <secondary>reverse dictionary</secondary>
                                    </indexterm>
                                </itermset>
                            </info>Going the other direction is not so easy, however: just as real
                            dictionaries do not support finding a word given a definition, neither
                            do dictionary structures support finding a key given a value.</para>
                    </footnote></para>
                <para audience="CORE" xml:id="para-kxj_q4r_lr"><phrase role="statement">Dictionaries
                        are ubiquitous in resource descriptions.</phrase> Structured descriptions
                    entered using a form are easily represented as dictionaries, where the form
                    items' labels are the properties and the data entered are the values. Tabular
                    data with a <quote>header row</quote> can be thought of as a set of
                    dictionaries, where column headers are the properties for each dictionary, and
                    each row is a set of corresponding values. Dictionaries are also a basic type of
                    data structure found in nearly all programming languages (referred to as
                    associative arrays).</para>
                <para audience="CORE" xml:id="para-ddk_q4r_lr"><info><itermset>
                    <indexterm zone="para-ddk_q4r_lr">
                        <primary>constraints</primary>
                        <secondary>data types and values</secondary>
                    </indexterm></itermset>
        </info>Again, we can introduce or remove constraints to define specialized
                    types of dictionaries. A sorted dictionary adds an ordering over entries; in
                    other words, it is a list of entries rather than a set. A
                        <emphasis>multimap</emphasis> is a dictionary in which multiple entries may
                    have the same key.</para>
            </section>
            <!--              -->
            <section xml:id="section-9.2.1.5" label="9.2.1.5">
                <title>Trees</title>
                <info>
                    <itermset>
                        <indexterm zone="section-9.2.1.5">
                            <primary>resource description</primary>
                            <secondary>structures</secondary>
                            <tertiary>trees</tertiary>
                        </indexterm>
                        <indexterm zone="section-9.2.1.5">
                            <primary>tree</primary>
                        </indexterm></itermset>
        </info>

                <para audience="CORE" xml:id="para-bgk_q4r_lr"><info><itermset>
                    <indexterm zone="para-bgk_q4r_lr">
                        <primary>alphabetical ordering</primary>
                    </indexterm></itermset>
        </info><phrase role="statement">In dictionaries as they are commonly
                        understood, properties are terms and values are their corresponding
                        definitions.</phrase> The terms and values are usually words, phrases, or
                    other expressions that can be ordered alphabetically. But if generalize the
                    notion of a dictionary as abstract sets of property-value pairs, the values can
                    be anything at all. In particular, the values can themselves be dictionaries.
                        <phrase role="statement">When a dictionary structure has values that are
                        themselves dictionaries, we say that the dictionaries are
                            <emphasis>nested</emphasis>.</phrase> Nesting is very useful for
                    resource descriptions that need more structure than what a (non-nested)
                    dictionary can provide.</para>
                <figure xml:id="figure-9-2" label="9.2">
                    <title>Four Nested Dictionaries.</title>
                    <mediaobject xml:id="figure-9-2a">
                        <imageobject>
                            <imagedata fileref="figs/Figure-8.2.jpg" format="JPG"/>
                        </imageobject>
                        <textobject>
                            <phrase role="ALT descriptive">A graphical representation of nested
                                dictionaries.</phrase>
                        </textobject>
                        <caption>
                            <para audience="CORE" xml:id="para-q4k_q4r_lr"><phrase role="caption"
                                    >When a dictionary contains other dictionaries, they are said to
                                    be nested.</phrase></para>
                        </caption>
                    </mediaobject>
                </figure>
                <para audience="CORE" role="descriptive" xml:id="para-v3k_q4r_lr"><xref
                        linkend="figure-9-2"/> presents an example of nested dictionaries.
                    At the top level there is one dictionary with a single entry having the property
                        <emphasis>a</emphasis>. The value associated with <emphasis>a</emphasis> is
                    a dictionary consisting of two entries, the first having property
                        <emphasis>b</emphasis> and the second having property
                    <emphasis>c</emphasis>. The values associated with <emphasis>b</emphasis> and
                    with <emphasis>c</emphasis> are also dictionaries.</para>
                <para audience="CORE" role="descriptive" xml:id="para-wlk_q4r_lr"><phrase
                        role="statement">If we nest dictionaries like this, and our
                            <quote>top</quote> dictionary (the one that contains all the others) has
                        only one entry, then we have a kind of <glossterm linkend="gloss_tree"
                            >tree</glossterm> structure.</phrase>
                    <xref linkend="figure-9-3" xrefstyle="short"/> shows the same
                    properties and values as <xref linkend="figure-9-2"
                        xrefstyle="select: label"/>, this time arranged to make the tree structure
                    more visible. <glossterm linkend="gloss_tree">Trees</glossterm> consist of
                        <glossterm linkend="gloss_node" xreflabel="nodes">nodes</glossterm> (the
                    letters and numbers in <xref linkend="figure-9-3"
                        xrefstyle="select: label"/>) joined by <glossterm linkend="gloss_edge"
                        >edges</glossterm> (the arrows). Each node in the tree with a circle around
                    it is a property, and the value of each property consists of the nodes below (to
                    the right of) it in the tree. A node is referred to as the
                        <emphasis>parent</emphasis> of the nodes below it, which in turn are
                    referred to as the <emphasis>children</emphasis> of that node. The edges show
                    these <quote>parent of</quote> relationships between the nodes. The node with no
                    parent is called the <emphasis>root</emphasis> of the tree. Nodes with no
                    children are called <emphasis>leaf</emphasis> nodes.</para>
                <figure xml:id="figure-9-3" label="9.3">
                    <title>A Tree of Properties and Values.</title>

                    <mediaobject xml:id="figure-9-3a">
                        <imageobject>
                            <imagedata fileref="figs/Figure-8.3.jpg" format="JPG"/>
                        </imageobject>
                        <textobject>
                            <phrase role="ALT descriptive">A graphical representation of nested
                                dictionaries as a tree.</phrase>
                        </textobject>
                        <caption>
                            <para audience="CORE" xml:id="para-srk_q4r_lr"><phrase role="caption">An
                                    alternative representation of nested dictionaries is as a tree.
                                    The lowest level or leaf nodes of the tree contain property
                                    values.</phrase></para>
                        </caption>
                    </mediaobject>
                </figure>
                <para audience="Computing IA" xml:id="para-s5k_q4r_lr"><info>
                        <itermset>
                            <indexterm zone="para-s5k_q4r_lr">
                                <primary>constraints</primary>
                                <secondary>data types and values</secondary>
                            </indexterm>
                        </itermset>
                    </info>As with the other types of structures we have considered, we can define
                    different kinds of trees by introducing different types of constraints.
                        <phrase>For example, the predominant metamodel for <abbrev>XML</abbrev> is
                        documents is a kind of tree called the <firstterm xml:id="first_XML_Infoset"
                            linkend="gloss_XML_Infoset">XML Information Set</firstterm> or
                        Infoset.</phrase>
                    <footnote xml:id="endnote-448" label="525" audience="Computing">
                        <para audience="Computing" xml:id="para-oxk_q4r_lr"><info>
                                <itermset>
                                    <indexterm audience="Markup" zone="endnote-448">
                                        <primary>endnote</primary>
                                        <secondary>Computing</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-448">
                                        <primary>metamodel</primary>
                                        <secondary>mapping between</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-448">
                                        <primary>computing</primary>
                                        <secondary>metamodels meet</secondary>
                                    </indexterm>
                                </itermset>
                            </info>The XML Information Set <citation xml:id="cite_Cowan2004"
                                linkend="Cowan2004">(Cowan2004)</citation>
                        </para>
                        <para audience="Computing" xml:id="para-k1l_q4r_lr"><abbrev>RDF/XML</abbrev>
                            is one example where meta models meet. In <citetitle
                                linkend="Wilde2008b" pubwork="book">Document Design
                                Matters,</citetitle> <citation xml:id="cite_Wilde2008b"
                                linkend="Wilde2008b">(Wilde and Glushko 2008b)</citation> point out
                            that <quote>If the designer of an exchange format uses a
                                    non-<abbrev>XML</abbrev> conceptual metamodel because it seems
                                to be a better fit for the data model, <abbrev>XML</abbrev> is only
                                used as the physical layer for the exchange model. The logical layer
                                in this case defines the mapping between the
                                    non-<abbrev>XML</abbrev> conceptual model, and any
                                reconstruction of the exchange model data requires the consumer to
                                be fully aware of this mapping. In such a case, it is good practice
                                to make users of the <abbrev>API</abbrev> aware of the fact that it
                                is using a non-<abbrev>XML</abbrev> metamodel. Otherwise they might
                                be tempted to base their implementation on a too small set of
                                examples, creating implementations which are brittle and will fail
                                at some point in time.</quote></para>
                    </footnote></para>
                <para audience="CORE Computing IA" xml:id="para-sdl_q4r_lr"><info><itermset>
                    <indexterm zone="para-sdl_q4r_lr">
                        <primary>constraints</primary>
                        <secondary>graphs and trees</secondary>
                    </indexterm></itermset>
        </info><phrase role="statement">The <glossterm linkend="gloss_XML_Infoset"
                            >XML Information Set</glossterm> defines a specific kind of tree
                        structure by adding very specific constraints, including ordering of child
                        nodes, to the basic definition of a tree. The addition of an ordering
                        constraint distinguishes <abbrev>XML</abbrev> trees from nested
                        dictionaries, in which child nodes do not have any order (because dictionary
                        entries do not have an ordering).</phrase> Ordering is an important
                    constraint for resource descriptions, since without ordering it is impossible
                    to, for example, list multiple authors while guaranteeing that the order of
                    authors will be maintained. <xref linkend="figure-9-3"
                        xrefstyle="select: label"/> depicts a kind of tree with a different set of
                    constraints: all non-leaf nodes are properties, and all leafs are values. We
                    could also define a tree in which every node has both a property and a value.
                    Trees exist in a large variety of flavors, but they all share a common topology:
                    the edges between nodes are directed (one node is the parent and the other is
                    the child), and every node except the root has exactly one parent.</para>
                <note userlevel="Editor" xml:id="note-ch8-Editor-drh_5bs_lr">
                    <title>Editors' Note</title>
                    <para xml:id="para-rgl_q4r_lr">Bob, Ian says this is confusing: <quote>We could
                            also define a tree in which every node has both a property and a
                            value.</quote></para>
                </note>
                <para audience="CORE Computing IA" xml:id="para-sjl_q4r_lr">Trees provide a way to
                    group statements describing different but related resources. For example,
                    consider the description structured as a dictionary here: <example
                        xml:id="example-9-1" label="9.1" audience="CORE Computing IA">
                        <title>Description structured as a dictionary</title>
                        <literallayout>                    <emphasis role="strong">author given names <symbol>&#8594;</symbol> Winfried Georg</emphasis>
                    <emphasis role="strong">author surname <symbol>&#8594;</symbol> Sebald</emphasis>
                    <emphasis role="strong">title <symbol>&#8594;</symbol> Die Ringe des Saturn</emphasis>
                    <emphasis role="strong">pages <symbol>&#8594;</symbol> 371</emphasis></literallayout>
                    </example> The dictionary groups together four property-value pairs describing a
                    particular book. (The arrows are simply a schematic way to indicate
                    property-value relations. Later in the chapter we look at ways to
                        <quote>write</quote> these relations using some specific syntax.)</para>
                
                <?need 7.5cm ?>
                <para audience="CORE Computing IA" xml:id="para-qml_q4r_lr">But really the first two
                    entries are not describing the book; they are describing the book’s author. So,
                    it would be better to group those two statements somehow. We can do this by
                    nesting the entries describing the author within the book description, creating
                    a tree structure: <example xml:id="example-9-2" label="9.2"
                        audience="CORE">
                        <title>Nesting an author description within a book description</title>
                        <literallayout>                    <emphasis role="strong">author <symbol>&#8594;</symbol></emphasis>
                            <emphasis role="strong">given names <symbol>&#8594;</symbol> Winfried Georg</emphasis>
                            <emphasis role="strong">surname <symbol>&#8594;</symbol> Sebald</emphasis>
                    <emphasis role="strong">title <symbol>&#8594;</symbol> Die Ringe des Saturn</emphasis>
                    <emphasis role="strong">pages <symbol>&#8594;</symbol> 371</emphasis></literallayout>
                    </example> Using a tree works well in this case because we can treat the book as
                    the primary resource being described, making it the root of our tree, and adding
                    on the author description as a <quote>branch.</quote></para>
                
                <?need 7.5cm ?>
                
                <para audience="CORE Computing IA" xml:id="para-tpl_q4r_lr">We also could have
                    chosen to make the author the primary resource, giving us a tree like the one in
                        <xref linkend="example-9-3" xrefstyle="select: label"/>. <example
                        xml:id="example-9-3" label="9.3" audience="CORE">
                        <title>Nesting book descriptions within an author description</title>
                        <literallayout>                    <emphasis role="strong">given names <symbol>&#8594;</symbol> Winfried Georg</emphasis>
                    <emphasis role="strong">surname <symbol>&#8594;</symbol> Sebald</emphasis>
                    <emphasis role="strong">books authored <symbol>&#8594;</symbol></emphasis>
                            <emphasis role="strong">1. title <symbol>&#8594;</symbol> Die Ringe des Saturn</emphasis>
                                <emphasis role="strong">pages <symbol>&#8594;</symbol> 371</emphasis>
                            <emphasis role="strong">2. title <symbol>&#8594;</symbol> Austerlitz</emphasis>
                                <emphasis role="strong">pages <symbol>&#8594;</symbol> 416</emphasis></literallayout>
                    </example>
                </para>
                <para audience="Computing IA" xml:id="para-atl_q4r_lr">Note that in this dictionary,
                    the value of the <emphasis>books authored</emphasis> property is a
                        <emphasis>list</emphasis> of dictionaries. Making the author the primary or
                    root resource allows us to include multiple book descriptions in the tree (but
                    makes it more difficult to describe books having multiple authors). A tree is a
                    good choice for structuring descriptions as long as we can clearly identify a
                    primary resource. In some cases, however, we want to connect descriptions of
                    related resources without having to designate one as primary. In these cases, we
                    need a more flexible data structure.</para>
            </section>
            <!--              -->
            <?need 7.5cm ?>
            
            <section xml:id="section-9.2.1.6" label="9.2.1.6">
                <title>Graphs</title>
                <info>
                    <itermset>
                        <indexterm zone="section-9.2.1.6">
                            <primary>resource description</primary>
                            <secondary>structures</secondary>
                            <tertiary>graphs</tertiary>
                        </indexterm>
                        <indexterm zone="section-9.2.1.6">
                            <primary>graphs</primary>
                        </indexterm></itermset>
        </info>

                <para audience="CORE" xml:id="para-yvl_q4r_lr">Suppose we were describing two books,
                    where the author of one book is the subject of the other, as in <xref
                        linkend="example-9-4" xrefstyle="short"/>: <example
                        xml:id="example-9-4" label="9.4" audience="CORE">
                        <title>Two related descriptions</title>
                        <literallayout xml:id="cite_McCulloch2003">                    <emphasis role="strong">1. author <symbol>&#8594;</symbol> Mark Richard McCulloch</emphasis>
                        <emphasis role="strong">title <symbol>&#8594;</symbol> Understanding W. G. Sebald</emphasis>
                        <emphasis role="strong">subject <symbol>&#8594;</symbol> Winfried Georg Sebald</emphasis>
                    <emphasis role="strong">2. author <symbol>&#8594;</symbol> Winfried Georg Sebald</emphasis>
                        <emphasis role="strong">title <symbol>&#8594;</symbol> Die Ringe des Saturn</emphasis></literallayout>
                    </example> By looking at these descriptions, we can guess the relationship
                    between the two books, but that relationship is not explicitly represented in
                    the structure: we just have two separate dictionaries and have inferred the
                    relationship by matching property values. It is possible that this inference
                    could be wrong: there might be two people named <emphasis>Winfried Georg
                        Sebald</emphasis>. <phrase role="interrogative">How can we structure these
                        descriptions to explicitly represent the fact that the <emphasis>Winfried
                            Georg Sebald</emphasis> that is the subject of the first book is the
                        same <emphasis>Winfried Georg Sebald</emphasis> who authored the
                        second?</phrase></para>
                <para audience="CORE" xml:id="para-gzl_q4r_lr">One possibility would be to make
                        <emphasis>Winfried Georg Sebald</emphasis> the root of a tree, similar to
                    the approach taken in <xref linkend="example-9-3"/>, adding a
                        <emphasis>book about</emphasis> property alongside the <emphasis>books
                        authored</emphasis> one. This solution would work fine if people were our
                    primary resources, and it thus made sense to structure our descriptions around
                    them. But suppose that we had decided that our descriptions should be structured
                    around books, and that we were using a vocabulary that took this perspective
                    (with properties such as <emphasis>author</emphasis> and
                        <emphasis>subject</emphasis> rather than <emphasis>books authored</emphasis>
                    and <emphasis>books about</emphasis>). We should not let a particular structure
                    limit the organizational perspective we can take, as Batten’s cards did.
                    Instead, we should consciously choose structures to suit our organizational
                    perspective. How can we do this?</para>
                <para audience="CORE" role="descriptive" xml:id="para-ybm_q4r_lr"><info><itermset>
                    <indexterm significance="preferred" zone="def_graph">
                        <primary>graphs</primary>
                    </indexterm><indexterm zone="def_graph">
                        <primary>data structures</primary>
                        <secondary>graph</secondary>
                    </indexterm></itermset>
        </info>If we treat our
                    two book descriptions as trees, we can join the two branches (subject and
                    author) that share a value. When we do this, we no longer have a tree, because
                    we now have a node with more than one parent<phrase role="parenthetical"> (<xref
                            linkend="figure-9-4"/>)</phrase>. 
                    The structure in <xref linkend="figure-9-4"
                        xrefstyle="short"/> is a <glossterm linkend="gloss_graph">graph</glossterm>.
                        <phrase role="definition" xml:id="def_graph">Like a <glossterm
                            linkend="gloss_tree">tree</glossterm>, a <glossterm xreflabel="graph"
                            xml:id="term_graph">graph</glossterm> consists of a set of nodes
                        connected by edges. These edges may or may not have a direction<phrase
                            role="parenthetical"> (<xref linkend="section-6.6.3"/>)</phrase>. If
                        they do, the <glossterm linkend="gloss_graph">graph</glossterm> is referred
                        to as a <quote>directed graph.</quote> If a <glossterm linkend="gloss_graph"
                            >graph</glossterm> is directed, it may be possible to start at a node
                        and follow edges in a path that leads back to the starting node. Such a path
                        is called a <quote>cycle.</quote> If a directed graph has no cycles, it is
                        referred to as an <quote>acyclic graph.</quote></phrase></para>
                <para audience="CORE" xml:id="para-y2m_q4r_lr"><info>
                        <itermset>
                            <indexterm zone="para-y2m_q4r_lr">
                                <primary>constraints</primary>
                                <secondary>graphs and trees</secondary>
                            </indexterm>
                        </itermset>
                    </info>A tree is just a more constrained kind of <glossterm
                        linkend="gloss_graph">graph</glossterm>. Trees are
                        <emphasis>directed</emphasis> graphs because the <quote>parent of</quote>
                    relationship between nodes is asymmetric: the edges are arrows that point in a
                    certain direction. <phrase role="parenthetical">(See <xref
                            linkend="section-6.3.2.1"/>.)</phrase> Furthermore, trees are
                        <emphasis>acyclic</emphasis> graphs, because if you follow the directed
                    edges from one node to another, you can never encounter the same node twice.
                    Finally, trees have the constraint that every node (except the root) must have
                    exactly one parent.<footnote xml:id="endnote-449" label="526"
                        audience="Computing">
                        <para audience="Computing" xml:id="para-zhm_q4r_lr"><info>
                                <itermset>
                                    <indexterm audience="Markup" zone="endnote-449">
                                        <primary>endnote</primary>
                                        <secondary>Computing</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-449">
                                        <primary>rooted tree</primary>
                                    </indexterm>
                                    <indexterm zone="endnote-449">
                                        <primary>tree</primary>
                                        <secondary>rooted</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-449">
                                        <primary>computing</primary>
                                        <secondary>rooted tree</secondary>
                                    </indexterm>
                                </itermset>
                            </info>Technically, what is described here is referred to as
                                <quote>rooted tree</quote> by mathematicians, who define trees more
                            generally. Since trees used as data structures are always rooted trees,
                            we do not make the distinction here.</para>
                    </footnote></para>
                <para audience="CORE" xml:id="para-vkm_q4r_lr"><info><itermset>
                    <indexterm zone="para-vkm_q4r_lr">
                        <primary>constraints</primary>
                        <secondary>graphs and trees</secondary>
                    </indexterm></itermset>
        </info>In <xref linkend="figure-9-4"/> we have violated this
                    constraint by joining our two book trees. The graph that results is still
                    directed and acyclic, but because the <emphasis>Winfried George
                        Sebald</emphasis> node now has two parents, it is no longer a tree.</para>
                
                <sidebar
                    xml:id="StopAndThink-9.2.1.6-social-network-symmetry">
                    <?dbhtml sidebar-width="40%"?>
                    <?dbhtml float-type="right"?>
                    <?dbfo sidebar-width="50%" ?>
                    <?dbfo float-type="outside" ?>
                    <title>Stop and Think: Social Network Properties</title>
                    <info>
                        <itermset>
                            <indexterm zone="StopAndThink-9.2.1.6-social-network-symmetry" condition="print" userlevel="Professional Graduate">
                                <primary>Stop and Think</primary>
                                <secondary>Social Network Properties</secondary>
                            </indexterm>
                            <indexterm zone="StopAndThink-9.2.1.6-social-network-symmetry" userlevel="Professional Graduate">
                                <primary>Social Network Properties</primary>
                            </indexterm>
                            <indexterm zone="StopAndThink-9.2.1.6-social-network-symmetry">
                                <primary>symmetry</primary>
                            </indexterm></itermset>
        </info>
                    
                    <para xml:id="para-unm_q4r_lr">Compare the concept of <quote>friend</quote> in
                            <application>Facebook</application> with that of <quote>follower</quote>
                        in <application>Twitter</application>, in terms of the semantic properties
                        discussed in <xref linkend="section-6.3.2"/> and the graph properties
                        discussed in this section. </para>
                    
                </sidebar>
                
                <para audience="CORE" xml:id="para-qqm_q4r_lr"><glossterm linkend="gloss_graph"
                        >Graphs</glossterm> are very general and flexible structures. Many kinds of
                    systems can be conceived of as nodes connected by edges: stations connected by
                    subway lines, people connected by friendships, decisions connected by
                    dependencies, and so on. Relationships can be modeled in different ways using
                    different kinds of <glossterm linkend="gloss_graph">graph</glossterm>s. For
                    example, if we assume that friendship is symmetric<phrase role="parenthetical">
                        (see <xref linkend="section-6.3.2.1"/>)</phrase>, we would use an undirected
                        <glossterm linkend="gloss_graph">graph</glossterm> to model the
                    relationship. However, in web-based social networks friendship is often
                    asymmetric (you might <quote>friend</quote> someone who does not reciprocate),
                    so a directed <glossterm linkend="gloss_graph">graph</glossterm> is more
                    appropriate.</para>
                
                
                
                
                <figure xml:id="figure-9-4" floatstyle="true" label="9.4">
                    <title>Descriptions Linked into a Graph.</title>

                    <mediaobject xml:id="figure-9-4a">
                        <imageobject>
                            <imagedata fileref="figs/Figure-8.4.jpg" format="JPG"/>
                        </imageobject>
                        <textobject>
                            <phrase role="ALT descriptive">A graphical representation of resource
                                descriptions linked into a graph.</phrase>
                        </textobject>
                        <caption>
                            <para audience="CORE" xml:id="para-rtm_q4r_lr"><phrase role="caption"
                                    >Descriptions can be linked to form a graph when the value
                                    assigned to two different properties is the
                                same.</phrase></para>
                        </caption>
                    </mediaobject>
                </figure>
                <note userlevel="Editor" xml:id="note-ch8-Editor-v5h_5bs_lr">
                    <title>Editors' Note</title>
                    <para xml:id="para-rwm_q4r_lr">Bob, Ian asks (about following): i.e., a matrix?
                        illustration may be helpful.</para>
                </note>
                <para audience="CORE" xml:id="para-ozm_q4r_lr">Often it is useful to treat a
                        <glossterm linkend="gloss_graph">graph</glossterm> as a set of pairs of
                    nodes, where each pair may or may not be directly connected by an edge. Many
                    approaches to characterizing structural relationships among resources <phrase
                        role="parenthetical">(see <xref linkend="section-6.5.3"/>)</phrase> are
                    based on modeling the related resources as a set of pairs of nodes, and then
                    analyzing patterns of connectedness among them. As we will see, being able to
                    break down a <glossterm linkend="gloss_graph">graph</glossterm> into pairs is
                    also useful when we structure resource descriptions as <glossterm
                        linkend="gloss_graph">graph</glossterm>s.</para>
                <para audience="Computing IA" xml:id="para-ncn_q4r_lr">In <xref
                        linkend="section-9.4.1" xrefstyle="short"/> we will use <abbrev>XML</abbrev>
                    to model the graph shown in <xref linkend="figure-9-4"/> by using
                        <quote>references</quote> to connect a book to its title, authors and
                    subject. This will allow us to develop sophisticated graphs of knowledge within
                    a single XML document instance. <phrase role="parenthetical">(See also the
                        sidebar, <xref linkend="sidebar_XML_Transclusion_Features"
                        />)</phrase><footnote xml:id="endnote-450" label="527" audience="Computing">
                        <para audience="Computing" xml:id="para-ofn_q4r_lr"><info>
                                <itermset>
                                    <indexterm audience="Markup" zone="endnote-450">
                                        <primary>endnote</primary>
                                        <secondary>Computing</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-450">
                                        <primary>DTD</primary>
                                    </indexterm>
                                    <indexterm zone="endnote-450">
                                        <primary>schema</primary>
                                        <secondary>dependencies</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-450">
                                        <primary>W3C</primary>
                                    </indexterm>
                                    <indexterm zone="endnote-450">
                                        <primary>ISO</primary>
                                        <secondary>schema languages</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-450">
                                        <primary>computing</primary>
                                        <secondary>XML schemas</secondary>
                                    </indexterm>
                                </itermset>
                            </info>This feature relies upon the existence of an <abbrev>XML</abbrev>
                            schema. An <abbrev>XML</abbrev> schema can declare that certain
                            attributes are of type ID, IDREF or IDREFS. Whether an
                                <abbrev>XML</abbrev>
                            <abbrev>DTD</abbrev> or one of the many schema languages that have been
                            developed under the auspices of the <abbrev>W3C</abbrev> or
                                <abbrev>ISO</abbrev>.</para>
                    </footnote></para>
            </section>
        </section>
        <!--              -->
        <section xml:id="section-9.2.2" label="9.2.2">
            <title>Comparing Metamodels: JSON, XML and RDF</title>
            <info>
                <itermset>
                    <indexterm zone="section-9.2.2">
                        <primary>metamodel</primary>
                        <secondary>JSON, XML, RDF</secondary>
                    </indexterm>
                    <indexterm zone="section-9.2.2">
                        <primary>JSON</primary>
                        <secondary>metamodel</secondary>
                    </indexterm>
                    <indexterm zone="section-9.2.2">
                        <primary>XML</primary>
                        <secondary>metamodel</secondary>
                    </indexterm>
                    <indexterm zone="section-9.2.2">
                        <primary>RDF</primary>
                        <secondary>metamodel</secondary>
                    </indexterm></itermset>
        </info>

            <para audience="CORE" xml:id="para-g3n_q4r_lr">Now that we are familiar with the various
                kinds of metamodels used to structure resource descriptions, we can take a closer
                look at some specific metamodels. A detailed comparison of the affordances of
                different metamodels is beyond the scope of this chapter. Here we will simply take a
                brief look at three popular metamodels<symbol>&#8212;</symbol><abbrev>JSON</abbrev>,
                    <abbrev>XML</abbrev>, and <abbrev>RDF</abbrev><symbol>&#8212;</symbol>in order
                to see how they further specify and constrain the more general kinds of metamodels
                introduced above.</para>
            <!--              -->
            <section xml:id="section-9.2.2.1" label="9.2.2.1">
                <title>JSON</title>

                <glosslist>
                    <glossentry>
                        <glossterm xml:id="term_JSON" xreflabel="JavaScript Object Notation"
                            >JavaScript Object Notation (JSON)</glossterm>
                        <glossdef>
                            <para audience="CORE" xml:id="para-hln_q4r_lr"><info>
                                    <itermset>
                                        <indexterm significance="preferred" zone="def_JSON">
                                            <primary>JSON</primary>
                                        </indexterm>
                                        <indexterm zone="def_JSON">
                                            <primary>metamodel</primary>
                                            <secondary>JSON</secondary>
                                        </indexterm>
                                        <indexterm zone="def_JSON">
                                            <primary>writing system</primary>
                                            <secondary>JSON</secondary>
                                        </indexterm>
                                    </itermset>
                                </info><phrase role="definition" xml:id="def_JSON"><firstterm
                                        xml:id="first_JSON" linkend="gloss_JSON"
                                                ><citerefentry><refentrytitle>JavaScript Object
                                                Notation</refentrytitle><manvolnum>JSON</manvolnum></citerefentry></firstterm>
                                    is a textual format for exchanging data that borrows its
                                    metamodel from the JavaScript programming language.
                                    Specifically, the <abbrev>JSON</abbrev> metamodel consists of
                                    two kinds of structures found in JavaScript: lists (called
                                        <quote>arrays</quote> in JavaScript) and dictionaries
                                    (called <quote>objects</quote> in JavaScript).</phrase>  Lists
                                and dictionaries contain values, which may be strings of text,
                                numbers, Booleans (true or false), or the null (empty) value. Again,
                                these types of values are taken directly from JavaScript. Lists and
                                dictionaries can be values too, meaning lists and dictionaries can
                                be nested within one another to produce more complex structures such
                                as tables and trees.</para>
                        </glossdef>
                    </glossentry>
                </glosslist>
                <para audience="CORE" xml:id="para-e4n_q4r_lr">Lists, dictionaries, and a basic set
                    of value types constitute the <abbrev>JSON</abbrev> metamodel. Because this
                    metamodel is a subset of JavaScript, the <abbrev>JSON</abbrev> metamodel is very
                    easy to work with in JavaScript. Since JavaScript is the only programming
                    language that is available in all web browsers, <abbrev>JSON</abbrev> has become
                    a popular choice for developers who need to work with data and resource
                    descriptions on the web. <phrase role="parenthetical">(See <xref
                            linkend="section-9.3.2"/> later in this chapter.)</phrase> Furthermore,
                    many modern programming languages provide data structures and value types
                    equivalent to those provided by JavaScript. So, data represented as
                        <abbrev>JSON</abbrev> is easy to work with in many programming languages,
                    not just JavaScript.</para>
            </section>
            <!--              -->
            <section xml:id="section-9.2.2.2" label="9.2.2.2">
                <title>XML Information Set</title>
                <info>
                    <itermset>
                        <indexterm zone="section-9.2.2.2" userlevel="Professional Graduate">
                            <primary>XML Information Set</primary>
                            <secondary>metamodel</secondary>
                        </indexterm></itermset>
        </info>

                <para audience="CORE" xml:id="para-brn_q4r_lr">The <glossterm
                        linkend="gloss_XML_Infoset">XML Information Set</glossterm> metamodel is
                    derived from data structures used for document markup. <phrase
                        role="parenthetical">(See <xref linkend="section-5.2.2.2" xrefstyle="short"
                        />.)</phrase> These markup structures<symbol>&#8212;</symbol><glossterm
                        linkend="gloss_element">elements</glossterm> and <glossterm
                        linkend="gloss_attribute">attributes</glossterm><symbol>&#8212;</symbol>are
                    well suited for programmatically manipulating the structure of documents and
                    data together.<footnote xml:id="endnote-451" label="528" audience="Computing">
                        <para audience="Computing" xml:id="para-b5n_q4r_lr"><info>
                                <itermset>
                                    <indexterm audience="Markup" zone="endnote-451">
                                        <primary>endnote</primary>
                                        <secondary>Computing</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-451">
                                        <primary>computing</primary>
                                        <secondary>XML Infoset</secondary>
                                    </indexterm>
                                </itermset>
                            </info><link xmlns:xlink="http://www.w3.org/1999/xlink"
                                xlink:href="http://www.w3.org/TR/xml-infoset/"
                                    ><uri>http://www.w3.org/TR/xml-infoset/</uri></link>.</para>
                    </footnote></para>
                <glosslist>
                    <glossentry>
                        <glossterm>XML Infoset</glossterm>
                        <glossdef>
                            <para audience="CORE" xml:id="para-zwn_q4r_lr"><info>
                                    <itermset>
                                        <indexterm significance="preferred" zone="def_XML_Infoset">
                                            <primary>XML Information Set</primary>
                                        </indexterm>
                                        <indexterm zone="def_XML_Infoset">
                                            <primary>metamodel</primary>
                                            <secondary>XML Infoset</secondary>
                                        </indexterm>
                                    </itermset>
                                </info><phrase role="definition" xml:id="def_XML_Infoset">The
                                        <glossterm xreflabel="XML Infoset" xml:id="term_XML_Infoset"
                                        >XML Infoset</glossterm> is a tree structure, where each
                                    node of the tree is defined to be an <quote>information
                                        item</quote> of a particular type. Each information item has
                                    a set of type-specific properties associated with it. At the
                                    root of the tree is a <quote>document item,</quote> which has
                                    exactly one <quote>element item</quote> as its child. <indexterm
                                        significance="preferred" zone="def_element">
                                        <primary>element item</primary>
                                    </indexterm><indexterm zone="def_element">
                                        <primary>XML Information Set</primary>
                                        <secondary>element item</secondary>
                                    </indexterm><phrase role="definition" xml:id="def_element">An
                                            <glossterm xml:id="term_element">element</glossterm>
                                        item has a set of <glossterm linkend="gloss_attribute"
                                            >attribute</glossterm> items, and a list of child nodes.
                                        These child nodes may include other element items, or they
                                        may be character items.</phrase> (See <xref
                                        linkend="section-9.2.1"/> below for more on characters.)
                                        <glossterm linkend="gloss_attribute">Attribute</glossterm>
                                    items may contain character items, or they may contain typed
                                    data, such as name tokens, identifiers and references. Element
                                    identifiers and references (ID/IDREF) may be used to connect
                                    nodes, transforming a tree into a graph.</phrase>
                                <phrase audience="Computing">(See the sidebar, <xref
                                        linkend="sidebar_XML_Transclusion_Features"
                                    />)</phrase><footnote xml:id="endnote-452" label="529"
                                    audience="Computing">
                                    <para audience="Computing" xml:id="para-xzn_q4r_lr"><info>
                                            <itermset>
                                                <indexterm audience="Markup" zone="endnote-452">
                                                  <primary>endnote</primary>
                                                  <secondary>Computing</secondary>
                                                </indexterm>
                                                <indexterm zone="endnote-452">
                                                  <primary>computing</primary>
                                                  <secondary>XML metamodels</secondary>
                                                </indexterm>
                                            </itermset>
                                        </info>The <glossterm linkend="gloss_XML_Infoset">XML
                                            Infoset</glossterm> is one of many metamodels for
                                            <abbrev>XML</abbrev>, including the DOM and XPath.
                                        Typically, an XML Infoset is created as a by-product of
                                        parsing a well-formed <abbrev>XML</abbrev> document
                                        instance. An XML document may also be informed by its DTD or
                                        schema with information about the types of attribute values,
                                        and their default values. Attributes of type ID, IDREF and
                                        IDREFs provide a mechanism for intra-document hypertext
                                        linking and transclusion. An <abbrev>XML</abbrev> document
                                        instance may contain entity definitions and references that
                                        get expanded when the document is parsed, thereby offering
                                        another form of transclusion.</para>
                                </footnote></para>
                        </glossdef>
                    </glossentry>
                </glosslist>
                <para audience="CORE" xml:id="para-xc4_q4r_lr"><xref linkend="figure-9-5"
                    /> is a graphical representation of how an <abbrev>XML</abbrev> document might
                    be used to structure part of a description of an author and his works. This
                    example demonstrates how we might use element items to model the domain of the
                    description, by giving them names such as author and title. The character items
                    that are the children of these elements hold the content of the description:
                    author names, book titles, and so on. Attribute items are used to hold auxiliary
                    information about this content, such as its language.</para>
                <figure xml:id="figure-9-5" label="9.5">
                    <title>A Description Structure.</title>

                    <mediaobject xml:id="figure-9-5a">
                        <imageobject>
                            <imagedata fileref="figs/Figure-8.5.jpg" format="JPG"/>
                        </imageobject>
                        <textobject>
                            <phrase role="ALT descriptive">A graphical representation of an XML
                                document as a tree containing element, attribute and character
                                nodes.</phrase>
                        </textobject>
                        <caption>
                            <para audience="CORE" xml:id="para-ag4_q4r_lr"><phrase role="caption">An
                                    XML document can be described as a tree in which elements are
                                    nodes that can contain character content directly or attributes
                                    that contain character content.</phrase></para>
                        </caption>
                    </mediaobject>
                </figure>
                <para audience="CORE" xml:id="para-t34_q4r_lr">This example also demonstrates how
                    the <abbrev>XML</abbrev> Infoset supports mixed content by allowing element
                    items and character items to be <quote>siblings</quote> of the same parent
                    element. In this case, the Infoset structure allows us to specify that the book
                    description can be displayed as a line of text consisting of the original title
                    and the translated title in parentheses. The elements and attributes are used to
                    indicate that this line of text consists of two titles written in different
                    languages, not a single title containing parentheses.</para>
                <para audience="CORE" xml:id="para-tl4_q4r_lr">If not for mixed content, we could
                    not write narrative text with <glossterm linkend="gloss_hypertext_link"
                        >hypertext links</glossterm> embedded in the middle of a sentence. It gives
                    us the ability to identify the subcomponents of a sentence, so that we could
                    distinguish the terms <quote>Sebald,</quote>
                    <quote>walking</quote> and <quote>East Anglia</quote> as an author and two
                    subjects.</para>
                <sidebar xml:id="sidebar_XML_Transclusion_Features" audience="Computing IA">
                    <title>Inclusions and References</title>
                    <info>
                        <itermset>
                            <indexterm zone="sidebar_XML_Transclusion_Features" condition="print" userlevel="Professional Graduate">
                                <primary>sidebar</primary>
                                <secondary>Inclusions and References</secondary>
                            </indexterm>
                            <indexterm zone="sidebar_XML_Transclusion_Features" userlevel="Professional Graduate">
                                <primary>Inclusions and References</primary>
                            </indexterm>
                            <indexterm zone="sidebar_XML_Transclusion_Features">
                                <primary>Nelson, Ted</primary>
                                <secondary>transclusion</secondary>
                            </indexterm>
                            <indexterm zone="sidebar_XML_Transclusion_Features">
                                <primary>XML</primary>
                                <secondary>transclusion features</secondary>
                            </indexterm>
                            <indexterm zone="sidebar_XML_Transclusion_Features">
                                <primary>XML</primary>
                                <secondary>DTD</secondary>
                                <tertiary>entities</tertiary>
                            </indexterm>
                            <indexterm zone="sidebar_XML_Transclusion_Features">
                                <primary>XML</primary>
                                <secondary>DTD</secondary>
                                <tertiary>ID/IDREF</tertiary>
                            </indexterm></itermset>
        </info>

                    <para audience="CORE" xml:id="para-p44_q4r_lr">An <abbrev>XML</abbrev> Infoset
                        is typically the result of processing a well-formed <abbrev>XML</abbrev>
                        document instance.<footnote xml:id="endnote-453" label="530"
                            audience="Computing">
                            <para audience="Computing" xml:id="para-ur4_q4r_lr"><info>
                                    <itermset>
                                        <indexterm audience="Markup" zone="endnote-453">
                                            <primary>endnote</primary>
                                            <secondary>Computing</secondary>
                                        </indexterm>
                                        <indexterm zone="endnote-453">
                                            <primary>XML Information Set</primary>
                                            <secondary>synthetic</secondary>
                                        </indexterm>
                                        <indexterm zone="endnote-453">
                                            <primary>computing</primary>
                                            <secondary>synthetic Infoset</secondary>
                                        </indexterm>
                                    </itermset>
                                </info>A well-formed XML document instance, when processed, will
                                yield an XML Information Set, as described here. Information sets
                                may also be constructed by other means, such as transforming from
                                another information set. See the section on <citetitle
                                    pubwork="section">Synthetic Infosets</citetitle> at <link
                                    xmlns:xlink="http://www.w3.org/1999/xlink"
                                    xlink:href="http://www.w3.org/TR/xml-infoset/#intro.synthetic"
                                        ><uri>http://www.w3.org/TR/xml-infoset/#intro.synthetic</uri></link>
                                for details.</para>
                        </footnote>
                        <phrase role="statement">Schemas associated with <abbrev>XML</abbrev>
                            document instances <quote>inform</quote> the corresponding
                                <abbrev>XML</abbrev> Infoset. Thus, the <quote>truth value</quote>
                            of any XML Infoset is dependent upon its related
                            schemas.</phrase><footnote xml:id="endnote-454" label="531"
                            audience="Computing">
                            <para audience="Computing" xml:id="para-t54_q4r_lr"><info>
                                    <itermset>
                                        <indexterm audience="Markup" zone="endnote-454">
                                            <primary>endnote</primary>
                                            <secondary>Computing</secondary>
                                        </indexterm>
                                        <indexterm zone="endnote-454">
                                            <primary>computing</primary>
                                            <secondary>XML Infoset contributions</secondary>
                                        </indexterm>
                                        <indexterm zone="endnote-454">
                                            <primary>URI</primary>
                                            <secondary>base</secondary>
                                        </indexterm>
                                        <indexterm zone="endnote-454">
                                            <primary>computing</primary>
                                            <secondary>base URI</secondary>
                                        </indexterm>
                                        <indexterm zone="endnote-454">
                                            <primary>XML Information Set</primary>
                                            <secondary>contributions</secondary>
                                        </indexterm>
                                    </itermset>
                                </info>The Infoset contains knowledge of whether all related
                                declarations have been read and processed, the base
                                    <abbrev>URI</abbrev> of the document instance, information about
                                attribute types, comments, processing instructions, unparsed
                                entities and notations, and more.</para>
                            <para audience="Computing" xml:id="para-nx4_q4r_lr">A well-formed
                                    <abbrev>XML</abbrev> document instance for which there are
                                associated schemas, such as a <abbrev>DTD</abbrev>, may contribute
                                information to the Infoset. Notably, schemas may associate data
                                types with element and attribute information items, and it may also
                                specify default or fixed values for attributes. A
                                    <abbrev>DTD</abbrev> may define entities that are referenced in
                                the document instance and are expanded in-place when processed.
                                These contributions can affect the truth value of the
                                document.</para>
                        </footnote> Traditionally, any documentation that is related to the schema
                        is considered to be part of the schema definition and, at least notionally,
                        informs human understanding and interpretation of corresponding
                            documents.<footnote xml:id="endnote-455" label="532"
                            audience="Computing">
                            <para audience="Computing" xml:id="para-n1p_q4r_lr"><info>
                                    <itermset>
                                        <indexterm audience="Markup" zone="endnote-455">
                                            <primary>endnote</primary>
                                            <secondary>Computing</secondary>
                                        </indexterm>
                                        <indexterm zone="endnote-455">
                                            <primary>schema</primary>
                                            <secondary>semantics</secondary>
                                        </indexterm>
                                        <indexterm zone="endnote-455">
                                            <primary>computing</primary>
                                            <secondary>schema semantics</secondary>
                                        </indexterm>
                                        <indexterm zone="endnote-455">
                                            <primary>constraints</primary>
                                            <secondary>schema</secondary>
                                        </indexterm>
                                    </itermset>
                                </info>The <abbrev>SGML</abbrev> standard explicitly stated that
                                documentation describing or explaining a <abbrev>DTD</abbrev> is
                                part of the document type definition. The implication being that a
                                schema is not just about defining syntax, but also semantics.
                                Moreover, since <abbrev>DTD</abbrev>s do not make possible to
                                describe all possible constraints, such as co-occurrence
                                constraints, the documentation could serve as human-consumable
                                guidance for implementers as well as content creators and
                                consumers.</para>
                        </footnote></para>
                    <para audience="CORE" xml:id="para-ndp_q4r_lr">The <abbrev>XML</abbrev> family
                        offers several mechanisms to create inclusion relationships: by employing
                        element references; by way of entity definition and reference; by using
                            <firstterm xml:id="first_XInclude"><citerefentry xml:id="ref_XInclude"
                                    ><refentrytitle>XML
                                    Inclusions</refentrytitle><manvolnum>XInclude</manvolnum></citerefentry></firstterm>
                        or XLink. These inclusions and references can also inform the XML Infoset,
                        if they are processed.</para>
                    <para audience="CORE" xml:id="para-kgp_q4r_lr">Any <abbrev>XML</abbrev> node may
                        refer to another node simply by referencing it by its assigned ID. Assuming
                        attributes are declared, the Infoset exposes this information as a
                            <emphasis>references</emphasis> property as an ordered list of element
                        information items. That is to say that an element may contain other element
                        nodes by subordination, or by reference.<footnote xml:id="endnote-456"
                            label="533" audience="Computing">
                            <para audience="Computing" xml:id="para-jjp_q4r_lr"><info>
                                    <itermset>
                                        <indexterm audience="Markup" zone="endnote-456">
                                            <primary>endnote</primary>
                                            <secondary>Computing</secondary>
                                        </indexterm>
                                        <indexterm zone="endnote-456">
                                            <primary>computing</primary>
                                            <secondary>XML ID/IDREF</secondary>
                                        </indexterm>
                                        <indexterm zone="endnote-456">
                                            <primary>ID/IDREF</primary>
                                        </indexterm>
                                        <indexterm zone="endnote-456">
                                            <primary>element node</primary>
                                            <secondary>references property</secondary>
                                        </indexterm>
                                    </itermset>
                                </info>Attribute types may be declared in an <abbrev>XML</abbrev>
                                <abbrev>DTD</abbrev> or schema. Attributes whose type is ID must
                                have a valid <abbrev>XML</abbrev> name value that is unique within
                                that <abbrev>XML</abbrev> document; an attribute of type IDREF whose
                                value corresponds to a unique ID has a <quote>references</quote>
                                property whose value is the element node that corresponds to the
                                element with that ID. An attribute of type IDREFS whose value
                                corresponds to a list of unique ID has a <quote>references</quote>
                                property whose value is a list of element node(s) that corresponds
                                to the element(s) with matching IDs.</para>
                        </footnote></para>
                    <para audience="CORE" xml:id="para-slp_q4r_lr">XInclude <quote>specifies a
                            processing model and syntax for general purpose inclusion. Inclusion is
                            accomplished by merging a number of XML information sets into a single
                            composite infoset.</quote> XInclude offers the most versatile mechanism
                        for addressing whole documents, specific information items, ranges of
                        information items, and even parts of information items, which has led to its
                        widespread adoption in document processing.<footnote xml:id="endnote-457"
                            label="534" audience="Computing">
                            <para audience="Computing" xml:id="para-q4p_q4r_lr"><info>
                                    <itermset>
                                        <indexterm audience="Markup" zone="endnote-457">
                                            <primary>endnote</primary>
                                            <secondary>Computing</secondary>
                                        </indexterm>
                                        <indexterm zone="endnote-457">
                                            <primary>computing</primary>
                                            <secondary>XInclude</secondary>
                                        </indexterm>
                                        <indexterm zone="endnote-457">
                                            <primary>XInclude</primary>
                                        </indexterm>
                                    </itermset>
                                </info>XML Inclusions (XInclude) is <citation
                                    xml:id="cite_Marsh2006" linkend="Marsh2006">(Marsh, Orchard, and
                                    Veillard 2006)</citation>.</para>
                        </footnote></para>
                    <para audience="CORE" xml:id="para-nrp_q4r_lr">XLink <quote>allows elements to
                            be inserted into XML documents in order to create and describe links
                            between resources. It uses XML syntax to create structures that can
                            describe links similar to the simple unidirectional hyperlinks of
                            today’s HTML, as well as more sophisticated links.</quote><footnote
                            xml:id="endnote-458" label="535" audience="Computing">
                            <para audience="Computing" xml:id="para-n5p_q4r_lr"><info>
                                    <itermset>
                                        <indexterm audience="Markup" zone="endnote-458">
                                            <primary>endnote</primary>
                                            <secondary>Computing</secondary>
                                        </indexterm>
                                        <indexterm zone="endnote-458">
                                            <primary>computing</primary>
                                            <secondary>XLink</secondary>
                                        </indexterm>
                                        <indexterm zone="endnote-458">
                                            <primary>DeRose, Steve</primary>
                                        </indexterm>
                                        <indexterm zone="endnote-458">
                                            <primary>Maler, Eve</primary>
                                        </indexterm>
                                        <indexterm zone="endnote-458">
                                            <primary>Walsh, Norman</primary>
                                        </indexterm>
                                        <indexterm zone="endnote-458">
                                            <primary>Orchard, David</primary>
                                        </indexterm>
                                    </itermset>
                                </info>XML Linking Language (XLink) is <citation
                                    xml:id="cite_DeRose2010" linkend="DeRose2010">(DeRose, Maler,
                                    Orchard, and Walsh 2010)</citation>.</para>
                        </footnote></para>
                    <para audience="CORE" xml:id="para-ixp_q4r_lr">Entities are similar to macros
                        found in many programming languages; a value is assigned to a token, the
                        token is referenced wherever the value is needed, and macro expansion
                        happens when the XML document instance is read into the Infoset.<footnote
                            xml:id="endnote-459" label="536" audience="Computing">
                            <para audience="Computing" xml:id="para-f1q_q4r_lr"><info>
                                    <itermset>
                                        <indexterm audience="Markup" zone="endnote-459">
                                            <primary>endnote</primary>
                                            <secondary>Computing</secondary>
                                        </indexterm>
                                        <indexterm zone="endnote-459">
                                            <primary>computing</primary>
                                            <secondary>XML entity reference</secondary>
                                        </indexterm>
                                    </itermset>
                                </info>Within the document’s DTD, one simply declares the entity and
                                its corresponding value, which could be anything from an entire
                                document to a phrase and then it may be referenced in place within
                                the <abbrev>XML</abbrev> document instance. The entity reference is
                                replaced by the entity value in the <abbrev>XML</abbrev> Infoset.
                                Entities, as nameable wrappers, effectively disappear on their way
                                into the <abbrev>XML</abbrev> Infoset.</para>
                        </footnote> Entities are a handy feature, but since they are expanded on
                        their way in, entities do not survive as information items in the
                            <abbrev>XML</abbrev> Infoset. The ID/IDREF feature is more popular than
                        the use of entities because it carries more information into the
                            <abbrev>XML</abbrev> Infoset.</para>
                </sidebar>
                <para audience="CORE" xml:id="para-hdq_q4r_lr"><info><itermset>
                    <indexterm zone="para-hdq_q4r_lr">
                        <primary>abstraction</primary>
                        <secondary>level</secondary>
                    </indexterm></itermset>
        </info><phrase role="statement">Using schemas to define data representation
                        formats is a good practice that facilitates shared understanding and
                        contributes to long-term maintainability in institutional or business
                        contexts.</phrase> An <abbrev>XML</abbrev> schema represents a contract
                    among the parties subscribing to its definitions, whereas <abbrev>JSON</abbrev>
                    depends on out-of-band communication among programmers. The notion that
                        <quote>the code is the documentation</quote> may be fashionable among
                    programmers, but modelers prefer to design at a higher level of abstraction and
                    then implement.</para>
                <para audience="CORE" role="contrast" xml:id="para-fgq_q4r_lr">The
                        <abbrev>XML</abbrev> Infoset presents a strong contrast to
                        <abbrev>JSON</abbrev> and does not always map in a straightforward way to
                    the data structures used in popular web scripting languages. Whereas
                        <abbrev>JSON</abbrev>’s structures make it easier for object-oriented
                    programmers to readily exchange data, they lack any formal schema language and
                    cannot easily handle mixed content.</para>
            </section>
            <!--              -->
            <section xml:id="section-9.2.2.3" label="9.2.2.3">
                <title>RDF</title>
                <info>
                    <itermset>
                        <indexterm zone="section-9.2.2.3">
                            <primary>RDF</primary>
                            <secondary>metamodel</secondary>
                        </indexterm></itermset>
        </info>

                <para audience="CORE" xml:id="para-cjq_q4r_lr">In <xref linkend="figure-9-4"
                        xrefstyle="short"/>, we structured our resource description as a graph by
                    treating resources, properties, and values as nodes, with edges reflecting their
                    combination into descriptive statements. However, a more common approach is to
                    treat resources and values as nodes, and properties as the edges that connect
                    them. <xref linkend="figure-9-6"/> shows the same description as <xref
                        linkend="figure-9-4" xrefstyle="short"/>, this time with properties treated
                    as edges. This roughly corresponds to the particular kind of graph metamodel
                    defined by <glossterm linkend="gloss_RDF" xreflabel="RDF">RDF</glossterm>.
                        <phrase role="parenthetical">(<xref linkend="section-5.2.2.4"
                    />)</phrase></para>
                <figure xml:id="figure-9-6" floatstyle="true" label="9.6">
                    <title>Treating Properties as Edges Rather Than Nodes.</title>

                    <mediaobject xml:id="figure-9-6a">
                        <imageobject>
                            <imagedata fileref="figs/Figure-8.6.jpg" format="JPG"/>
                        </imageobject>
                        <textobject>
                            <phrase role="ALT descriptive">Graphical depiction of relationship among
                                resources, properties and values.</phrase>
                        </textobject>
                        <caption>
                            <para audience="CORE" xml:id="para-dmq_q4r_lr"><phrase role="caption">We
                                    can treat each component of a description as a pair of nodes (a
                                    resource and a value) with an edge (the property) linking them.
                                    Here, we have two book resources that are related to four values
                                    through five properties. The single value node, <quote>Winfried
                                        George Sebald</quote> is the subject of one book while being
                                    the author of the second book. The books are depicted as boxes,
                                    the edges as labeled arrows and the values as text
                                    strings.</phrase></para>
                        </caption>
                        <!--
                        <imageobject role="web">
                            <imagedata fileref="figs/web/Ch8-Figure-6.png" format="PNG"/>
                        </imageobject>
                        -->
                    </mediaobject>
                </figure>
                <para audience="CORE" xml:id="para-y4q_q4r_lr"><info><itermset>
                    <indexterm
                        significance="preferred" zone="def_triple">
                        <primary>triple</primary>
                    </indexterm><indexterm zone="def_triple">
                        <primary>RDF</primary>
                        <secondary>triple</secondary>
                    </indexterm></itermset>
        </info>We have noted that we can treat a
                    graph as a set of pairs of nodes, where each pair may be connected by an edge.
                    Similarly, we can treat each component of the description in <xref
                        linkend="figure-9-6" xrefstyle="short"/> as a pair of nodes (a
                    resource and a value) with an edge (the property) linking them. 
                    <phrase role="definition" xml:id="def_triple">In the RDF metamodel,
                        a pair of nodes and its edge is called a <glossterm xreflabel="triple"
                            xml:id="term_triple">triple</glossterm>, because it consists of three
                        parts (two nodes and one edge). The RDF metamodel is a directed graph, so it
                        identifies one node (the one from which the edge is pointing) as the
                            <glossterm xreflabel="subject" xml:id="term_subject">subject</glossterm>
                        of the triple, and the other node (the one to which the edge is pointing) as
                        its <glossterm xreflabel="object" xml:id="term_object">object</glossterm>.
                        The edge is referred to as the <glossterm xreflabel="predicate"
                            linkend="gloss_predicate">predicate</glossterm> or <phrase
                            role="parenthetical">(as we have been saying)</phrase>
                        <glossterm linkend="gloss_property" xreflabel="property"
                            >property</glossterm> of the triple.</phrase></para>
                <figure xml:id="figure-9-7" floatstyle="true" label="9.7">
                    <title>Listing Triples Individually.</title>

                    <mediaobject xml:id="chapter-8-figure-6a">
                        <imageobject>
                            <imagedata fileref="figs/Figure-8.7.jpg" format="JPG"/>
                        </imageobject>
                        <textobject>
                            <phrase role="ALT descriptive">Graphical depiction of relationship among
                                resources, properties and values.</phrase>
                        </textobject>
                        <caption>
                            <para audience="CORE" xml:id="para-xrq_q4r_lr"><phrase role="caption"
                                    >Lists each of the triples individually. Here, each statement
                                    relates one resource to one value through an edge. Thus, we have
                                    two distinct <quote>Winfried George Sebald</quote> value nodes.
                                    The books are depicted as boxes, the edges as labeled arrows and
                                    the values as text strings.</phrase></para>
                        </caption>
                    </mediaobject>
                </figure>
                <para audience="CORE" xml:id="para-y5q_q4r_lr"><xref linkend="figure-9-7"/> lists
                    separately all the triples in <xref linkend="figure-9-6"
                        xrefstyle="select: label"/> However, there is something missing in <xref
                        linkend="figure-9-7" xrefstyle="select: label"/>. <xref linkend="figure-9-6"
                        xrefstyle="select: label"/> clearly indicates that the <emphasis>Winfried
                        George Sebald</emphasis> who is the subject of book 1 is the same
                        <emphasis>Winfried George Sebald</emphasis> who is the author of book 2. In
                        <xref linkend="figure-9-7"/> this relationship is not clear. <phrase
                        role="interrogative">How can we tell if the <emphasis>Winfried George
                            Sebald</emphasis> of the third triple is the same as the
                            <emphasis>Winfried George Sebald</emphasis> of the triple statement? For
                        that matter, how can we tell if the first three triples all involve the same
                        book 1?</phrase> This is easy to show in a diagram of the entire description
                    graph, where we can have multiple edges attached to a node. But when we
                    disaggregate that graph into triples, we need some way of uniquely referring to
                    nodes. We need identifiers<phrase role="parenthetical"> (<xref
                            linkend="section-4.4.3"/>)</phrase>. When two triples have nodes with
                    the same identifier, we can know that it is the same node. RDF achieves this by
                    associating URIs with nodes. (See <xref linkend="section-5.2.2.4"/>)</para>
                <para audience="CORE" xml:id="para-zxq_q4r_lr">The need to identify nodes when we
                    break down an <abbrev>RDF</abbrev> graph into triples becomes important when we
                    want to <quote>write</quote>
                    <abbrev>RDF</abbrev> graphs<symbol>&#8212;</symbol>create textual
                    representations of them instead of depicting them<symbol>&#8212;</symbol>so that
                    they can be exchanged as data. Tree structures do not necessarily have this
                    problem, because it is possible to textually represent a tree structure without
                    having to mention any node more than once. Thus, one price paid for the
                    generality and flexibility of graph structures is the added complexity of
                    recording, representing or writing those structures.</para>
            </section>
            <!--              -->
            <section xml:id="section-9.2.2.4" label="9.2.2.4">
                <title>Choosing Your Constraints</title>


                
                <para audience="CORE" xml:id="para-v1r_q4r_lr"><info><itermset>
                    <indexterm zone="para-v1r_q4r_lr">
                        <primary>tradeoffs</primary>
                        <secondary>flexibility and complexity</secondary>
                    </indexterm><indexterm zone="para-v1r_q4r_lr">
                        <primary>constraints</primary>
                        <secondary>graphs and trees</secondary>
                    </indexterm></itermset>
        </info>This tradeoff between flexibility and complexity illustrates a more
                    general point about constraints. <phrase role="statement">In the context of
                        managing and interacting with resource descriptions, constraints are a good
                        thing.</phrase> As discussed above, a tree is a graph with very specific
                    constraints. These constraints allow you to do things with trees that are not
                    possible with graphs in general, such as representing them textually without
                    repeating yourself, or uniquely identifying nodes by the path from the root of
                    the tree to that node. This can make managing descriptions and the resources
                    they describe easier and more
                        efficient<symbol>&#8212;</symbol><emphasis>if</emphasis> a tree structure is
                    a good fit to the requirements of the organizing system. For example, an ordered
                    tree structure is a good fit for the hierarchical structure of the content of a
                    book or book-like document, such as an aircraft service manual or an SEC filing.
                    On the other hand, the network of relationships among the people and
                    organizations that collaborated to produce a book might be better represented
                    using a graph structure. <abbrev>XML</abbrev> is most often used to represent
                    hierarchies, but is also capable of representing network structures.</para>
            </section>
        </section>
        <!--              -->
        <section xml:id="section-9.2.3" label="9.2.3">
            <title>Modeling within Constraints</title>
            <info>
                <itermset>
                    <indexterm zone="section-9.2.3">
                        <primary>modeling</primary>
                        <secondary>with constraints</secondary>
                    </indexterm></itermset>
        </info>

            <para audience="CORE" xml:id="para-tdr_q4r_lr"><info><itermset>
                <indexterm zone="para-tdr_q4r_lr">
                    <primary>constraints</primary>
                    <secondary>models</secondary>
                </indexterm></itermset>
        </info><phrase role="statement">A metamodel imposes certain constraints on the
                    structure of our resource descriptions.</phrase> But in organizing systems, we
                usually need to further specify the content and composition of descriptions of the
                specific types of resources being organized. For example, when designing a system
                for organizing books, it is not sufficient to say that a book’s description is
                structured using <abbrev>XML</abbrev>, because the <abbrev>XML</abbrev> metamodel
                constrains structure and not the content of descriptions. We need also to specify
                that a book description includes a list of contributors, each entry of which
                provides a name and indicates the role of that contributor. This kind of
                specification is a <emphasis>model</emphasis> to which our descriptions of books are
                expected to conform. <phrase role="parenthetical">(See <xref
                        linkend="section-5.3.1.2"/>.)</phrase></para>
            <para audience="CORE" xml:id="para-qgr_q4r_lr"><info>
                    <itermset>
                        <indexterm zone="para-qgr_q4r_lr">
                            <primary>ONIX</primary>
                        </indexterm>
                    </itermset>
                </info>When designing an organizing system we may choose to reuse a standard model.
                For example, <citerefentry><refentrytitle><abbrev>ONIX</abbrev> for
                        Books</refentrytitle></citerefentry> is a standard model (conforming to the
                    <abbrev>XML</abbrev> metamodel) developed by the publishing industry for
                describing books.<footnote xml:id="endnote-460" label="537" audience="Business">
                    <para audience="Business" xml:id="para-pjr_q4r_lr"><info>
                            <itermset>
                                <indexterm audience="Markup" zone="endnote-460">
                                    <primary>endnote</primary>
                                    <secondary>Business</secondary>
                                </indexterm>
                                <indexterm zone="endnote-460">
                                    <primary>business</primary>
                                    <secondary>ONIX</secondary>
                                </indexterm>
                                <indexterm zone="endnote-460">
                                    <primary>ONIX</primary>
                                </indexterm>
                            </itermset>
                        </info><citerefentry xml:id="ref_ONIX"><refentrytitle>Online Information
                                Exchange</refentrytitle><manvolnum>ONIX</manvolnum></citerefentry>
                        is the international standard for representing and communicating book
                        industry product information in electronic form: <link
                            xmlns:xlink="http://www.w3.org/1999/xlink"
                            xlink:href="http://www.editeur.org/11/Books/"
                                ><uri>http://www.editeur.org/11/Books/</uri></link>.</para>
                </footnote></para>
            <para audience="CORE" xml:id="para-qmr_q4r_lr"><info>
                    <itermset>
                        <indexterm zone="para-qmr_q4r_lr">
                            <primary>constraints</primary>
                            <secondary>models</secondary>
                        </indexterm>
                    </itermset>
                </info>If no such standard exists, or existing standards do not suit our needs, we
                may create a new model for our specific domain. But we will not usually create a new
                metamodel: instead we will make choices from among the metamodels, such as
                    <abbrev>JSON</abbrev>, <abbrev>XML</abbrev>, or <abbrev>RDF</abbrev>, that have
                been formally recognized and incorporated into existing standards. <phrase
                    role="statement">Once we have selected a metamodel, we know the constraints we
                    have to work with when modeling the resources and collections in our specific
                    domain.</phrase><footnote xml:id="endnote-461" label="538" audience="Computing">
                    <para audience="Computing" xml:id="para-ppr_q4r_lr"><info>
                            <itermset>
                                <indexterm audience="Markup" zone="endnote-461">
                                    <primary>endnote</primary>
                                    <secondary>Computing</secondary>
                                </indexterm>
                                <indexterm zone="endnote-461">
                                    <primary>computing</primary>
                                    <secondary>vocabularies</secondary>
                                </indexterm>
                                <indexterm zone="endnote-461">
                                    <primary>vocabulary</primary>
                                    <secondary>design</secondary>
                                    <tertiary>caution advised</tertiary>
                                </indexterm>
                            </itermset>
                        </info>Do not take on the task of creating a new <abbrev>XML</abbrev> model
                        lightly. Literally thousands of <abbrev>XML</abbrev> vocabularies have been
                        created, and some represent hundreds or thousands of hours of effort. See
                            <citation xml:id="cite_Bray2005" linkend="Bray2005">(Bray
                            2005)</citation> for advice on how to reduce the risk of vocabulary
                        design if you cannot find an existing one that satisfies your
                        requirements.</para>
                </footnote></para>
            <!--              -->
            <section xml:id="section-9.2.3.1" label="9.2.3.1">
                <title>Specifying Vocabularies and Schemas</title>

                <para audience="CORE" xml:id="para-lsr_q4r_lr"><phrase role="statement">Creating a
                        model for descriptions of resources in a particular domain involves
                        specifying the common elements of those descriptions, and giving those
                        elements standard names.</phrase>
                    <phrase role="parenthetical">(See <xref linkend="section-5.3"/>)</phrase> The
                    model may also specify how these elements are arranged into larger structures,
                    for example, how they are ordered into lists nested into trees. Metamodels vary
                    in the tools they provide for specifying the structure and composition of
                    domain-specific models, and in the maturity and robustness of the methods for
                    designing them.<footnote xml:id="endnote-462" label="539" audience="Computing">
                        <para audience="Computing" xml:id="para-kvr_q4r_lr"><info>
                                <itermset>
                                    <indexterm audience="Markup" zone="endnote-462">
                                        <primary>endnote</primary>
                                        <secondary>Computing</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-462">
                                        <primary>computing</primary>
                                        <secondary>domain-specific languages</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-462">
                                        <primary>vocabulary</primary>
                                        <secondary>design</secondary>
                                        <tertiary>best practices</tertiary>
                                    </indexterm>
                                </itermset>
                            </info>See <citation xml:id="cite_Glushko2005-9.1" linkend="Glushko2005"
                                >(Glushko and McGrath 2005)</citation> for a synthesis of best
                            practices for creating domain-specific languages in technical publishing
                            and business-to-business document exchange contexts. You need best
                            practices for big problems, while small ones can be attacked with
                                <foreignphrase xml:lang="Latn">ad hoc</foreignphrase>
                            methods.</para>
                    </footnote>
                    <abbrev>RDF</abbrev> and <abbrev>XML</abbrev> each provide different,
                    metamodel-specific tools to define a model for a specific domain. But not every
                    metamodel provides such tools.</para>
                <para audience="CORE" xml:id="para-hyr_q4r_lr">In <abbrev>XML</abbrev>, models are
                    defined in separate documents known as <glossterm linkend="gloss_schema"
                        xreflabel="">schemas</glossterm>. <phrase role="statement">An
                            <abbrev>XML</abbrev> schema defining a domain model provides a
                        vocabulary of terms that can be used as element and attribute names in
                            <abbrev>XML</abbrev> documents that adhere to that model.</phrase> For
                    example, <citerefentry><refentrytitle>Onix for
                        Books</refentrytitle></citerefentry> schema specifies that an author of a
                    book should be called a <literal>Contributor</literal>, and that the page count
                    should be called an <literal>Extent</literal>. An <abbrev>XML</abbrev> schema
                    also defines rules for how those elements, attributes, and their content can be
                    arranged into higher-level structures. For example, the
                            <citerefentry><refentrytitle>Onix for
                        Books</refentrytitle></citerefentry> specifies that the description of a
                    book must include a list of <literal>Contributor</literal> elements, that this
                    list must have at least one element in it, and that each
                        <literal>Contributor</literal> element must have a
                        <literal>ContributorRole</literal> child element.</para>
                <para audience="Computing IA" xml:id="para-dbs_q4r_lr">If an <abbrev>XML</abbrev>
                    schema is given an identifier, <abbrev>XML</abbrev> documents can use that
                    identifier to indicate that they use terms and rules from that schema. An
                        <abbrev>XML</abbrev> document may use vocabularies from more than one
                        <abbrev>XML</abbrev> schema.<footnote xml:id="endnote-463" label="540"
                        audience="Computing">
                        <para audience="Computing" xml:id="para-c2s_q4r_lr"><info>
                                <itermset>
                                    <indexterm audience="Markup" zone="endnote-463">
                                        <primary>endnote</primary>
                                        <secondary>Computing</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-463">
                                        <primary>document semantics</primary>
                                    </indexterm>
                                    <indexterm zone="endnote-463">
                                        <primary>semantics</primary>
                                        <secondary>document schema</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-463">
                                        <primary>computing</primary>
                                        <secondary>namespaces</secondary>
                                    </indexterm>
                                </itermset>
                            </info>Unless an <abbrev>XML</abbrev> instance is associated with a
                            schema, it is fair to say that it does not have any model at all because
                            there is no way to understand the content and structure of the
                            information it contains. The assignment of a schema to an
                                <abbrev>XML</abbrev> instance requires a <quote>Document Type
                                Declaration.</quote> If some of the same vocabulary terms occur in
                            more than one <abbrev>XML</abbrev> schema, with different meanings in
                            each, using elements from more than one schema in the same instance
                            requires that they be distinguished using <glossterm
                                linkend="gloss_namespace">namespaces.</glossterm> For example, if an
                            element named <quote>title</quote> means the <quote>title of the
                                book</quote> in one schema and <quote>the honorific associated with
                                a person</quote> in another, instances might have elements with
                            namespace prefixes like &lt;book:title&gt;The Discipline of
                            Organizing&lt;/book:title&gt; and
                            &lt;hon:title&gt;Professor&lt;/hon:title&gt;. Namespaces are a common
                            source of frustration in <abbrev>XML</abbrev>, because they seem like an
                            overly complicated solution to a simple problem. But in addition to
                            avoiding naming collisions, they are important in schema composition and
                            organization.</para>
                    </footnote>
                    <phrase role="statement">Associating a schema with an <abbrev>XML</abbrev>
                        instance enables <glossterm linkend="gloss_validation"
                            xreflabel="validation">validation</glossterm>: automatically checking
                        that vocabulary terms are being used correctly.</phrase><footnote
                        xml:id="endnote-464" label="541" audience="Computing">
                        <para audience="Computing" xml:id="para-dhs_q4r_lr"><info>
                                <itermset>
                                    <indexterm audience="Markup" zone="endnote-464">
                                        <primary>endnote</primary>
                                        <secondary>Computing</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-464">
                                        <primary>language</primary>
                                        <secondary>validation</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-464">
                                        <primary>computing</primary>
                                        <secondary>validation</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-464">
                                        <primary>constraints</primary>
                                        <secondary>schema</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-464">
                                        <primary>XSD</primary>
                                    </indexterm>
                                </itermset>
                            </info>What <quote>correctly</quote> means depends on the schema
                            language used to encode the conceptual model of the document type. The
                                <abbrev>XML</abbrev> family of standards includes several schema
                            languages that differ in how completely they can encode a document
                            type’s conceptual model. The <citerefentry><refentrytitle>Document Type
                                    Definition</refentrytitle><manvolnum>DTD</manvolnum></citerefentry>
                            has its origins in publishing and enforces structural constraints well;
                            it expresses strong data typing through associated documentation
                            resources. <firstterm xml:id="first_XSD"
                                        ><citerefentry><refentrytitle>XML Schema Definition
                                        Language</refentrytitle><manvolnum>XSD</manvolnum></citerefentry></firstterm>
                            is better for representing transactional document types but its added
                            expressive power tends to make it more complex.</para>
                    </footnote></para>
                <para audience="CORE" xml:id="para-eks_q4r_lr"><phrase role="statement">If two
                        descriptions share the same <abbrev>XML</abbrev> schema and use only that
                        schema, then combining them is straightforward.</phrase> If not, it can be
                    problematic, unless someone has figured out exactly how the two schemas should
                        <quote>map</quote> to one another. Finding such a mapping is not a trivial
                    problem, as <abbrev>XML</abbrev> schemas may differ semantically, lexically,
                    structurally, or architecturally despite sharing a common implementation form.
                    (See <xref linkend="chapter-6"/>.)</para>
                <para audience="CORE" xml:id="para-zms_q4r_lr"><phrase role="statement">Tree
                        structures can vary considerably while still conforming to the
                            <abbrev>XML</abbrev> Infoset metamodel.</phrase> Users of
                        <abbrev>XML</abbrev> often specify rules for checking whether certain
                    patterns appear in an <abbrev>XML</abbrev> document (document-level validation).
                    This is less often done with <abbrev>RDF</abbrev>, because graphs that conform
                    to the <abbrev>RDF</abbrev> metamodel all have the same structure: they are all
                    sets of triples. This shared structure makes it simple to combine different RDF
                    descriptions without worrying about checking structure at the document level.
                    However, sometimes it is desirable to check descriptions at the document level,
                    as when part of a description is required. As with <abbrev>XML</abbrev>, if
                    consumers of those descriptions want to assert that they expect those
                    descriptions to have a certain structure (such as a required property), they
                    must check them at the document level.</para>
                <para audience="CORE" xml:id="para-aqs_q4r_lr">Because the <abbrev>RDF</abbrev>
                    metamodel already defines structure, defining a domain-specific model in
                        <abbrev>RDF</abbrev> mainly involves specifying <abbrev>URI</abbrev>s and
                    names for predicates. <phrase role="definition" xml:id="def_RDF_vocabulary">A
                        set of <abbrev>RDF</abbrev> predicate names and <abbrev>URI</abbrev>s is
                        known as an <glossterm xreflabel="RDF vocabulary"
                            xml:id="term_RDF_vocabulary">RDF vocabulary</glossterm>.</phrase>
                    <phrase role="principle statement">Publication of vocabularies on the web and
                        the use of <abbrev>URI</abbrev>s to identify and refer to predicate
                        definitions are key principles of Linked Data and the <glossterm
                            linkend="gloss_semantic_web">Semantic Web</glossterm>.</phrase>
                    <phrase role="parenthetical">(Also see <xref linkend="section-6.8.1"
                            xrefstyle="short"/>, as well as later in this
                        chapter.)</phrase><footnote xml:id="endnote-465" label="542" audience="Web">
                        <para audience="Web" xml:id="para-ats_q4r_lr"><info>
                                <itermset>
                                    <indexterm audience="Markup" zone="endnote-465">
                                        <primary>endnote</primary>
                                        <secondary>Web</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-465">
                                        <primary>Web</primary>
                                        <secondary>linked open vocabularies</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-465">
                                        <primary>Linked Open Vocabularies</primary>
                                    </indexterm>
                                </itermset>
                            </info>For example, see <citerefentry><refentrytitle>Linked Open
                                    Vocabularies</refentrytitle></citerefentry> at <link
                                xmlns:xlink="http://www.w3.org/1999/xlink"
                                xlink:href="http://lov.okfn.org/dataset/lov/index.html"
                                    ><uri>http://lov.okfn.org/dataset/lov/index.html</uri></link>.</para>
                    </footnote></para>
                <para audience="CORE" xml:id="para-aws_q4r_lr"><info><itermset>
                    <indexterm zone="para-aws_q4r_lr">
                        <primary>cataloging</primary>
                        <secondary>RDA</secondary>
                    </indexterm><indexterm zone="para-aws_q4r_lr">
                        <primary>RDA</primary>
                    </indexterm></itermset>
        </info>For example, the <citerefentry><refentrytitle>Resource Description
                            and Access</refentrytitle><manvolnum>RDA</manvolnum></citerefentry>
                    standard for cataloging library resources includes a set of <abbrev>RDF</abbrev>
                    vocabularies defining predicates usable in cataloging descriptions. One such
                    predicate is:
                    <programlisting xml:id="pro_id00001" linenumbering="unnumbered">        &lt;http://rdvocab.info/Elements/extentOfText&gt;</programlisting>
                    which is defined as <quote>the number and type of units and/or subunits making
                        up a resource consisting of text, with or without accompanying
                        illustrations.</quote> The vocabulary further specifies that this predicate
                    is a refinement of a more general predicate:
                    <programlisting xml:id="pro_id00002" linenumbering="unnumbered">        &lt;http://rdvocab.info/Elements/extent&gt;</programlisting>
                    which can be used to indicate, <quote>the number and type of units and/or
                        subunits making up a resource</quote> regardless of whether it is textual or
                    not.</para>
                <para audience="CORE" xml:id="para-wys_q4r_lr"><phrase role="statement"
                            ><abbrev>JSON</abbrev> lacks any standardized way to define which terms
                        can be used.</phrase> That does not mean one cannot use a standard
                    vocabulary when creating descriptions using <abbrev>JSON</abbrev>, only that
                    there is no agreed-upon way to use <abbrev>JSON</abbrev> to communicate which
                    vocabulary is being used, and no way to automatically check that it is being
                    used correctly.</para>
            </section>
            <!--              -->
            <section xml:id="section-9.2.3.2" label="9.2.3.2">
                <title>Controlling Values</title>

                <para audience="CORE" xml:id="para-act_q4r_lr">So far, we have focused on how models
                    specify vocabularies of terms and how those terms can be used in descriptions.
                    But models may also constrain the values or content of descriptions. <phrase
                        role="statement">Sometimes, a single model will define both the terms that
                        can be used for property names and the terms that can be used for property
                        values.</phrase> For example, an <abbrev>XML</abbrev> schema may enumerate a
                    list of valid terms for an attribute value.<footnote xml:id="endnote-466"
                        label="543" audience="Computing">
                        <para audience="Computing" xml:id="para-y2t_q4r_lr"><info>
                                <itermset>
                                    <indexterm audience="Markup" zone="endnote-466">
                                        <primary>endnote</primary>
                                        <secondary>Computing</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-466">
                                        <primary>computing</primary>
                                        <secondary>constraints</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-466">
                                        <primary>constraints</primary>
                                        <secondary>data types and values</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-466">
                                        <primary>attribute</primary>
                                        <secondary>value constraints</secondary>
                                    </indexterm>
                                </itermset>
                            </info>Attribute values can be constrained in a schema by specifying a
                            data type, a default value, and a list of potential values. Data types
                            allow us to specify whether a value is supposed to be a name, a number,
                            a date, a token or a string of text. Having established the data type,
                            we can further constrain the value of an attribute by specifying a range
                            of values, for a number or a date, for example. We can also use
                                <glossterm linkend="gloss_regular_expressions">regular
                                expression</glossterm> patterns to describe a data type such as a
                            postal code, telephone number or <abbrev>ISBN</abbrev> number.
                            Specifying default values and lists of legal values for attributes
                            simplifies content creation and quality assurance processes. In
                            Schematron, a rule-based XML schema language for making test assertions
                            about XML documents, we can express constraints between elements and
                            attributes in ways that other XML schema languages cannot. For example,
                            we can express the constraint that if two <tag class="starttag"
                                >title</tag> elements are provided, then each must contain a unique
                            string value and different <tag class="attribute">language</tag>
                            attribute values.</para>
                    </footnote></para>
                <para audience="CORE" xml:id="para-tht_q4r_lr"><info>
                        <itermset>
                            <indexterm zone="para-tht_q4r_lr">
                                <primary>LOC-SH</primary>
                            </indexterm>
                            <indexterm zone="para-tht_q4r_lr">
                                <primary>MeSH</primary>
                            </indexterm>
                        </itermset>
                    </info>Often, however, there are separate, specialized vocabularies of terms
                    intended for use as property values in resource descriptions. Typically these
                    vocabularies provide values for use within statements that describe what a
                    resource is about. Examples of such subject vocabularies include the
                            <citerefentry><refentrytitle>Library of Congress Subject
                            Headings</refentrytitle><manvolnum>LOC-SH</manvolnum></citerefentry> and
                    the <firstterm xml:id="first_MESH"><citerefentry><refentrytitle>Medical Subject
                                Headings</refentrytitle><manvolnum>MeSH</manvolnum></citerefentry></firstterm>.<footnote
                        xml:id="endnote-467" label="544" audience="LIS">
                        <para audience="LIS" xml:id="para-ukt_q4r_lr"><info>
                                <itermset>
                                    <indexterm audience="Markup" zone="endnote-467">
                                        <primary>endnote</primary>
                                        <secondary>LIS</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-467">
                                        <primary>library science</primary>
                                        <secondary>LOC-SH</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-467">
                                        <primary>library science</primary>
                                        <secondary>MeSH</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-467">
                                        <primary>LOC-SH</primary>
                                    </indexterm>
                                    <indexterm zone="endnote-467">
                                        <primary>MeSH</primary>
                                    </indexterm>
                                </itermset>
                            </info>See <abbrev>LOC-SH</abbrev> as <link
                                xmlns:xlink="http://www.w3.org/1999/xlink"
                                xlink:href="http://id.loc.gov/authorities/subjects.html"
                                    ><uri>http://id.loc.gov/authorities/subjects.html</uri></link>;
                            MeSH at <link xmlns:xlink="http://www.w3.org/1999/xlink"
                                xlink:href="http://www.nlm.nih.gov/mesh/"
                                    ><uri>http://www.nlm.nih.gov/mesh/</uri></link>.</para>
                    </footnote> Other vocabularies may provide authoritative names for people,
                    corporations, or places. Classification schemes are yet another kind of
                    vocabulary, providing the category names for use as the values in descriptive
                    statements that classify resources.</para>
                <para audience="CORE" xml:id="para-unt_q4r_lr"><info><itermset>
                    <indexterm zone="para-unt_q4r_lr">
                        <primary>metadata</primary>
                        <secondary>Metadata Authority Description Standard (MADS)</secondary>
                    </indexterm><indexterm zone="para-unt_q4r_lr">
                        <primary>MADS</primary>
                    </indexterm><indexterm zone="para-unt_q4r_lr">
                        <primary>SKOS</primary>
                    </indexterm> 
                </itermset>
        </info>Because different metamodels take
                    different approaches to specifying vocabularies, there will usually be different
                    versions of these vocabularies for use with different metamodels. 
                    
                    For example the <abbrev>LCSH</abbrev> are available both as
                        <abbrev>XML</abbrev> conforming to the <firstterm xml:id="first_MADS"
                            ><citerefentry xml:id="ref_MADS"><refentrytitle>Metadata Authority
                                Description
                            Standard</refentrytitle><manvolnum>MADS</manvolnum></citerefentry></firstterm>
                    schema, and as <abbrev>RDF</abbrev> using the <firstterm xml:id="first_SKOS"
                                ><citerefentry><refentrytitle>Simple Knowledge Organization
                                System</refentrytitle><manvolnum>SKOS</manvolnum></citerefentry></firstterm>
                    vocabulary.</para>
                <note userlevel="Editor">
                    <title>Editors' Note</title>
                    <para xml:id="para-ub4_tt4_hv">Numeric values and ranges. Units. </para>
                    <para xml:id="para-wct_yt4_hv">When is a number not a number? (Apartment number)
                        Average/mean apartment number makes no sense. </para>
                </note>
                <para audience="CORE" xml:id="para-oqt_q4r_lr"><phrase role="statement">Specifying a
                        vocabulary is just one way models can control what values can be assigned to
                        properties.</phrase> Another strategy is to specify what types of values can
                    be assigned. For example, a model for book descriptions may specify that the
                    value of a <emphasis>pages</emphasis> property must be a positive integer. Or it
                    could be more specific; a course catalog might give each course an identifier
                    that contains a two-letter department code followed by a 1-3 digit course
                    number. Specifying a data type like this with a <glossterm
                        linkend="gloss_regular_expressions">regular expression</glossterm> narrows
                    down the set of possible values for the property without having to enumerate
                    every possible value. (See the sidebar.)</para>
                <para audience="CORE" xml:id="para-ott_q4r_lr"><info>
                        <itermset>
                            <indexterm significance="preferred" zone="def_encoding_scheme">
                                <primary>encoding scheme</primary>
                            </indexterm>
                            <indexterm zone="def_encoding_scheme">
                                <primary>writing system</primary>
                                <secondary>encoding scheme</secondary>
                            </indexterm>
                        </itermset>
                    </info>In addition to or in lieu of specifying a type, a model may specify an
                    encoding scheme for values. <phrase role="definition"
                        xml:id="def_encoding_scheme">An <glossterm xml:id="term_encoding_scheme"
                            >encoding scheme</glossterm> is a specialized <glossterm
                            linkend="gloss_writing_system">writing system</glossterm> or syntax for
                        particular types of values.</phrase> For example, a model like Atom for
                    describing syndicated web content requires a publication date. But there are
                    many different ways to write dates: <literal>9/2/76</literal>, <literal>2 Sept.
                        1976</literal>, <literal>September 2nd 1976</literal>, etc. Atom also
                    specifies an encoding scheme for date values. The encoding scheme is RFC3339, a
                    standard for writing dates. When using RFC3339, one always writes a date using
                    the same form: <literal>1976-09-02</literal>.<footnote xml:id="endnote-468"
                        label="545" audience="Computing">
                        <para audience="Computing" xml:id="para-owt_q4r_lr"><info>
                                <itermset>
                                    <indexterm audience="Markup" zone="endnote-468">
                                        <primary>endnote</primary>
                                        <secondary>Computing</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-468">
                                        <primary>computing</primary>
                                        <secondary>Atom</secondary>
                                    </indexterm>
                                    <indexterm zone="endnote-468">
                                        <primary>Atom Publishing Protocol</primary>
                                    </indexterm>
                                </itermset>
                            </info>The Atom Publishing Protocol is IETF RFC 5023, (<link
                                xmlns:xlink="http://www.w3.org/1999/xlink"
                                xlink:href="https://tools.ietf.org/html/rfc5023"
                                    ><uri>https://tools.ietf.org/html/rfc5023</uri></link>); a good
                            introduction is <citation xml:id="cite_Sayre2005" linkend="Sayre2005"
                                >(Sayre 2005)</citation>. IETF RFC is <link
                                xmlns:xlink="http://www.w3.org/1999/xlink"
                                xlink:href="http://www.ietf.org/rfc/rfc3339.txt"
                                    ><uri>http://www.ietf.org/rfc/rfc3339.txt</uri></link>.</para>
                    </footnote></para>
                <sidebar xml:id="sidebar-regular_expressions" audience="Computing IA">
                    <title>Regular Expressions</title>
                    <info>
                        <itermset>
                            <indexterm zone="sidebar-regular_expressions" condition="print"
                                userlevel="Professional Graduate">
                                <primary>sidebar</primary>
                                <secondary>Regular Expressions</secondary>
                            </indexterm>
                            <indexterm zone="sidebar-regular_expressions">
                                <primary>regular expressions</primary>
                            </indexterm>
                        </itermset>
                    </info>
                    <para audience="CORE" xml:id="para-izt_q4r_lr"><glossterm
                            linkend="gloss_regular_expressions">Regular expressions</glossterm> have
                        been used to describe patterns in text documents since the early days of
                        computing and came into widespread use when Ken Thompson incorporated them
                        into early UNIX text processing tools, such as
                                <emphasis><application>ed</application></emphasis> and
                                <emphasis><application>grep</application></emphasis>. There are too
                        many variations of regular expression syntax for us to detail them here, but
                        it is worthwhile to consider them briefly while we are on the subject of
                        controlling values.<footnote xml:id="endnote-469" label="546"
                            audience="Computing">
                            <para audience="Computing" xml:id="para-hc5_q4r_lr"><info>
                                    <itermset>
                                        <indexterm audience="Markup" zone="endnote-469">
                                            <primary>endnote</primary>
                                            <secondary>Computing</secondary>
                                        </indexterm>
                                        <indexterm zone="endnote-469">
                                            <primary>computing</primary>
                                            <secondary>regular expressions</secondary>
                                        </indexterm>
                                    </itermset>
                                </info>There is no single authority on the subject of regular
                                expressions or their syntax. A good starting point is the Wikipedia
                                article on the subject: <link
                                    xmlns:xlink="http://www.w3.org/1999/xlink"
                                    xlink:href="http://en.wikipedia.org/wiki/Regular_expression"
                                        ><uri>http://en.wikipedia.org/wiki/Regular_expression</uri></link>.</para>
                        </footnote></para>
                    <para audience="CORE" xml:id="para-if5_q4r_lr">Regular expressions are employed
                        by modern text processing tools for selection and retrieval purposes. In
                        search and replace applications, one might search for the string
                                <quote><literal>Chapter [1-5]</literal></quote> to express your
                        intent to select chapters 1 through 5, or
                            <quote><literal>it[’]?s</literal></quote> to locate every use of
                            <quote>it’s</quote> and <quote>its</quote> in a manuscript; this
                        capability is highly valued by anyone who has had to edit a book. <phrase
                            role="statement">Programmers and data modelers use regular expressions
                            to describe expected encoding schemes when they design documents, data
                            elements, databases, and encoding schemes.</phrase> You experience
                        regular expression processing when you enter a phone number or postal code
                        into a Web-based form. Many data modeling, programming and XML schema
                        languages employ regular expressions to control data entry and validation of
                        values. In the context of controlling values, we can use regular expressions
                        to describe data values as varied as identifiers, names, dates, telephone
                        numbers, and postal codes. We can, likewise, define rules for white space
                        handling and punctuation within a data value.</para>
                </sidebar>
                <para audience="CORE" xml:id="para-g35_q4r_lr"><info><itermset>
                    <indexterm zone="para-g35_q4r_lr">
                        <primary>ISBN</primary>
                    </indexterm></itermset>
        </info><phrase role="statement">Encoding schemes are often defined in
                        conjunction with standardized identifiers.</phrase>
                    <phrase role="parenthetical">(See <xref linkend="section-4.4.3.1"/>.)</phrase>
                    For example, <citerefentry><refentrytitle>International Standard Book
                            Numbers</refentrytitle><manvolnum>ISBN</manvolnum></citerefentry> are
                    not just sequences of Arabic numerals: they are values written using the
                        <abbrev>ISBN</abbrev> encoding scheme. This scheme specifies how to separate
                    the sequence of numerals into parts, and how each of these parts should be
                    interpreted. The ISBN <literal>978-3-8218-4448-0</literal> has five parts, the
                    first three of which indicate that the resource with this identifier is 1) a
                    product of the book publishing industry, 2) published in a German-speaking
                    country, and 3) published by the publishing house
                    <orgname>Eichborn</orgname>.</para>
                <para audience="CORE" xml:id="para-el5_q4r_lr">Encoding schemes can be viewed as
                    very specialized models of particular kinds of information, such as dates or
                    book identifiers. But because they specify not only the structure of this
                    information, but also how it should be written, we can also view them as
                    specialized <glossterm linkend="gloss_writing_system">writing
                        systems</glossterm>. That is, encoding schemes specify how to
                        <emphasis>textually represent</emphasis> information.</para>
                <para audience="CORE" xml:id="para-f45_q4r_lr">In the second half of this chapter,
                    we will focus on the issues involved in textually representing resource
                        descriptions<symbol>&#8212;</symbol>writing them. Graphs, trees,
                    dictionaries, lists, and sets are general types of structures found in different
                    metamodels. Thinking about these broad types and how they fit or do not fit the
                    ways we want to model our resource descriptions can help us select a specific
                    metamodel. Specific metamodels such as the <abbrev>XML</abbrev> Infoset or
                        <abbrev>RDF</abbrev> are formalized and standardized definitions of the more
                    general types of structures discussed above. Once we have selected a metamodel,
                    we know the constraints we have to work with when modeling the <glossterm
                        linkend="gloss_resource">resources</glossterm> and collections in our
                    specific domain. But because metamodels are abstract and exist only on a
                    conceptual level, they can only take us so far. If we want to create, store, and
                    exchange individual resource descriptions, we need to make the structures
                    defined by our abstract metamodels concrete. We need to write them.</para>
            </section>
        </section>
        
        <!-- ###################### SECTION ########################################### -->
    </section>
    <!--              -->
    <?need 15cm ?>
    <section xml:id="section-9.3" label="9.3">
        <title>Writing Descriptions</title>
        <info>
            <itermset>
                <indexterm zone="section-9.3">
                    <primary>resource description</primary>
                    <secondary>form</secondary>
                    <tertiary>writing</tertiary>
                </indexterm>
                <indexterm zone="section-9.3">
                    <primary>resource description</primary>
                    <secondary>form</secondary>
                    <tertiary>microformats</tertiary>
                </indexterm>
                <indexterm zone="section-9.3">
                    <primary>resource description</primary>
                    <secondary>form</secondary>
                    <tertiary>microdata</tertiary>
                </indexterm>
                <indexterm zone="section-9.3">
                    <primary>resource description</primary>
                    <secondary>form</secondary>
                    <tertiary>HTML</tertiary>
                </indexterm>
                <indexterm zone="section-9.3">
                    <primary>Die Ringes des Saturn</primary>
                </indexterm>
                <indexterm zone="section-9.3">
                    <primary>resource description</primary>
                    <secondary>form</secondary>
                    <tertiary>attributes</tertiary>
                </indexterm></itermset>
        </info>

        <para audience="CORE" xml:id="para-tfv_q4r_lr">Suppose that I am organizing books, and I
            have decided that it is important for the purposes of this organizing to know the title
            of each book and how many pages it has. Before me I have a book, which I examine to
            determine that its title is <citetitle linkend="Sebald1995" pubwork="book">Die Ringe des
                Saturn</citetitle> and it has 371 pages. <xref linkend="example-9-5"/> lists
            a few of the ways to write this description. Let us examine these various forms of
            writing to see what they have in common and where they differ. 
            <?need 5cm ?>
            <example xml:id="example-9-5" label="9.5" audience="CORE">
                <title>Basic ways of writing part of a book description.</title>
                <info>
                    <itermset>
                        <indexterm zone="example-9-5">
                            <primary>resource description</primary>
                            <secondary>form</secondary>
                            <tertiary>XML</tertiary>
                        </indexterm>
                        <indexterm zone="example-9-5">
                            <primary>resource description</primary>
                            <secondary>form</secondary>
                            <tertiary>RDF</tertiary>
                        </indexterm>
                        <indexterm zone="example-9-5">
                            <primary>resource description</primary>
                            <secondary>form</secondary>
                            <tertiary>JSON</tertiary>
                        </indexterm></itermset>
        </info>
                <informaltable>
                    <tgroup cols="1">
                        <colspec colnum="1" colname="c1" rowsep="1"/>
                        <tbody>
                            <row>
                                <entry align="center">
                                    <para audience="CORE" xml:id="para-t3v_q4r_lr">The title is
                                            <emphasis>Die Ringe des Saturn</emphasis> and it has 371
                                        pages.</para>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <programlisting>{ book: {"title":"Die Ringe des Saturn","pages":371} }</programlisting>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <programlisting>&lt;book pages="371"&gt; &lt;title&gt;Die Ringe des Saturn&lt;/title&gt; &lt;/book&gt;</programlisting>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <programlisting>&lt;div class="book"&gt;The title is 
&lt;span class="title"&gt;Die Ringe des Saturn&lt;/span&gt;
and it has &lt;span class="pages"&gt;371 pages.&lt;/span&gt;
&lt;/div&gt;</programlisting>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <programlisting>&lt;http://lccn.loc.gov/96103072&gt;
&lt;http://rdvocab.info/Elements/title&gt; "Die Ringe des Saturn"@de ;
&lt;http://rdvocab.info/Elements/extentOfText&gt; "371 p." .</programlisting>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
            </example> We examine the notations, writing systems and syntax of each of these
            description forms, and others, in the following sections.</para>
        <!--              -->
        <section xml:id="section-9.3.1" label="9.3.1">
            <title>Notations</title>
            <info>
                <itermset>
                    <indexterm zone="section-9.3.1">
                        <primary>notation</primary>
                        <secondary>resource description</secondary>
                    </indexterm>
                    <indexterm zone="section-9.3.1">
                        <primary>resource description</primary>
                        <secondary>form</secondary>
                        <tertiary>notation</tertiary>
                    </indexterm></itermset>
        </info>

            <para audience="CORE" xml:id="para-wlv_q4r_lr"><info>
                    <itermset>
                        <indexterm zone="para-wlv_q4r_lr">
                            <primary>character</primary>
                            <secondary>set</secondary>
                        </indexterm>
                    </itermset>
                </info>First, let us look at the actual marks on the page. To write you must make
                marks or<symbol>&#8212;</symbol>more likely<symbol>&#8212;</symbol>select from a
                menu of marks using a keyboard. In either case, you are using a <glossterm
                    linkend="gloss_notation" xreflabel="notation">notation</glossterm>: <phrase
                    role="definition" xml:id="def_notation">a set of characters with distinct
                    forms.</phrase><footnote xml:id="endnote-470" label="547" audience="Computing">
                        <para audience="Computing" xml:id="para-s4v_q4r_lr"><info>
                            <itermset>
                                <indexterm audience="Markup" zone="endnote-470">
                                    <primary>endnote</primary>
                                    <secondary>Computing</secondary>
                                </indexterm>
                                <indexterm zone="endnote-470" userlevel="Professional">
                                    <primary>computing</primary>
                                    <secondary>citations</secondary>
                                </indexterm>
                            </itermset>
                        </info>The terminology here and in the following sections comes from
                            <citation xml:id="cite_Harris1996" linkend="Harris1996">(Harris
                            1996)</citation>.</para>
                </footnote>
                <phrase role="statement">The Latin alphabet is a notation, as are Arabic numerals.
                    Some more exotic notations include the symbols used for editorial markup and
                    alchemical symbols.</phrase><footnote xml:id="endnote-471" label="548"
                    audience="Computing">
                    <para audience="Computing" xml:id="para-srv_q4r_lr"><info>
                            <itermset>
                                <indexterm audience="Markup" zone="endnote-471">
                                    <primary>endnote</primary>
                                    <secondary>Computing</secondary>
                                </indexterm>
                                <indexterm zone="endnote-471">
                                    <primary>computing</primary>
                                    <secondary>Unicode chart</secondary>
                                </indexterm>
                            </itermset>
                        </info>See <link xmlns:xlink="http://www.w3.org/1999/xlink"
                            xlink:href="http://unicode.org/charts/PDF/U1F700.pdf."
                                ><uri>http://unicode.org/charts/PDF/U1F700.pdf</uri></link>.</para>
                </footnote>
                <phrase role="statement">The characters in a notation usually have an
                    ordering.</phrase> Arabic numerals are ordered <emphasis>1 2 3</emphasis> and so
                on. English-speaking children usually learn the ordering of the Latin alphabet in
                the form of an alphabet song.<footnote xml:id="endnote-472" label="549"
                    audience="CogSci">
                    <para audience="CogSci" xml:id="para-s5v_q4r_lr"><info>
                            <itermset>
                                <indexterm audience="Markup" zone="endnote-472">
                                    <primary>endnote</primary>
                                    <secondary>CogSci</secondary>
                                </indexterm>
                                <indexterm zone="endnote-472">
                                    <primary>cognitive science</primary>
                                    <secondary>alphabet song</secondary>
                                </indexterm>
                                <indexterm zone="endnote-472">
                                    <primary>Mozart, Wolfgang Amadeus</primary>
                                </indexterm>
                                <indexterm zone="endnote-472">
                                    <primary>Twinkle, Twinkle, Little Star</primary>
                                </indexterm>
                            </itermset>
                        </info>Entitled <quote>The ABC,</quote> the song was copyrighted in
                            <date>1835</date> by Boston music publisher <orgname>Charles
                            Bradlee</orgname>. It is sung to a tune that was originally developed by
                                <personname><firstname>Wolfgang</firstname>
                            <othername>Amadeus</othername>
                            <surname>Mozart</surname></personname>, and is commonly recognizable as
                            <citetitle>Twinkle, Twinkle, Little Star.</citetitle></para>
                </footnote></para>
            <para audience="CORE" xml:id="para-txv_q4r_lr"><info><itermset>
                <indexterm zone="para-txv_q4r_lr">
                    <primary>ASCII</primary>
                </indexterm></itermset>
        </info><phrase role="statement">A character may
                    belong to more than one notation.</phrase> The examples in <xref
                    xrefstyle="short" linkend="example-9-5"/> use characters from a few
                different notations: the letters of the Latin alphabet, Arabic numerals, and a
                handful of auxiliary marks: <literal>. { } " :&lt; &gt; / $</literal> Collectively,
                all of these characters<symbol>&#8212;</symbol>alphabet, numerals, and auxiliary
                    marks<symbol>&#8212;</symbol>also belong to a notation called the 
                <citerefentry><refentrytitle>American Standard Code for Information
                        Interchange</refentrytitle><manvolnum>ASCII</manvolnum></citerefentry>.<footnote
                    xml:id="endnote-473" label="550" audience="Computing">
                            <para audience="Computing" xml:id="para-w1w_q4r_lr"><info>
                            <itermset>
                                <indexterm audience="Markup" zone="endnote-473">
                                    <primary>endnote</primary>
                                    <secondary>Computing</secondary>
                                </indexterm>
                                <indexterm zone="endnote-473">
                                    <primary>computing</primary>
                                    <secondary>ASCII</secondary>
                                </indexterm>
                            </itermset>
                        </info><link xmlns:xlink="http://www.w3.org/1999/xlink"
                            xlink:href="http://tools.ietf.org/html/rfc20"
                                ><uri>http://tools.ietf.org/html/rfc20</uri></link>.</para>
                </footnote></para>
            <para audience="CORE" xml:id="para-tdw_q4r_lr"><info>
                    <itermset>
                        <indexterm zone="para-tdw_q4r_lr">
                            <primary>ASCII</primary>
                        </indexterm>
                        <indexterm significance="preferred" zone="def_character_encoding">
                            <primary>character encoding</primary>
                        </indexterm>
                        <indexterm zone="def_character_encoding">
                            <primary>notation</primary>
                            <secondary>character encoding</secondary>
                        </indexterm>
                    </itermset>
                </info><phrase role="statement"><abbrev xreflabel="ASCII">ASCII</abbrev> is an
                    example of a notation that has been codified and standardized for use in a
                    digital environment.</phrase> A traditional notation like the Latin alphabet can
                withstand a certain degree of variation in the form of a particular mark. Two people
                might write the letter <emphasis>A</emphasis> rather differently, but as long as
                they can mutually recognize each other’s marks as an <quote>A,</quote> they can
                successfully share a notation. Computers, however, cannot easily accommodate such
                variation. Each character must be strictly defined. In the case of
                    <abbrev>ASCII</abbrev>, each character is given a number from 0 to 127, so that
                there are 128 <abbrev xreflabel="ASCII">ASCII</abbrev> characters.<footnote
                    xml:id="endnote-474" label="551" audience="Computing">
                    <para audience="Computing" xml:id="para-vgw_q4r_lr"><info>
                            <itermset>
                                <indexterm audience="Markup" zone="endnote-474">
                                    <primary>endnote</primary>
                                    <secondary>Computing</secondary>
                                </indexterm>
                                <indexterm zone="endnote-474">
                                    <primary>ASCII</primary>
                                </indexterm>
                                <indexterm zone="endnote-474">
                                    <primary>computing</primary>
                                    <secondary>ASCII</secondary>
                                </indexterm>
                            </itermset>
                        </info>Only 95 of these characters are actually <quote>marks</quote> in the
                        sense of being visible and printable. The other 33 <abbrev xreflabel="ASCII"
                            >ASCII</abbrev> characters are <quote>control codes</quote> that
                        indicate things like horizontal and vertical tabs, the ends of printed
                        lines, form feeds, and transmission control. We can think of many of these
                        as special auxiliary marks, similar to the kind of symbols editors and
                        proofreaders use to annotate texts.</para>
                </footnote> When using a computer to type <abbrev xreflabel="ASCII">ASCII</abbrev>
                characters, each key you press selects a character from this <quote>menu</quote> of
                128 characters. <phrase role="definition" xml:id="def_character_encoding">A notation
                    that has had numbers assigned to its characters is called a <glossterm
                        xreflabel="character encoding" xml:id="term_character_encoding">character
                        encoding</glossterm>.</phrase></para>
            
            
            <?need 10cm ?>
            <para audience="CORE" xml:id="para-ojw_q4r_lr">
                <table frame="all" colsep="1" rowsep="1" pgwide="1" xml:id="table-ascii">
                    <title>ASCII</title>
                    <tgroup cols="9" align="center">
                        <colspec colname="c1" colnum="1" colwidth="6%" align="left" colsep="1"/>
                        <colspec colname="c2" colnum="2" colwidth="14%"/>
                        <colspec colname="c3" colnum="3" colwidth="14%"/>
                        <colspec colname="c4" colnum="4" colwidth="11%"/>
                        <colspec colname="c5" colnum="5" colwidth="11%"/>
                        <colspec colname="c6" colnum="6" colwidth="11%"/>
                        <colspec colname="c7" colnum="7" colwidth="11%"/>
                        <colspec colname="c8" colnum="8" colwidth="11%"/>
                        <colspec colname="c9" colnum="9" colwidth="11%"/>
                        <thead>
                            <row rowsep="1">
                                <entry/>
                                <entry>0</entry>
                                <entry>1</entry>
                                <entry>2</entry>
                                <entry>3</entry>
                                <entry>4</entry>
                                <entry>5</entry>
                                <entry>6</entry>
                                <entry>7</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>0</entry>
                                <entry>NUL</entry>
                                <entry>DLE</entry>
                                <entry>space</entry>
                                <entry>0</entry>
                                <entry>@</entry>
                                <entry>P</entry>
                                <entry>`</entry>
                                <entry>p</entry>
                            </row>
                            <row>
                                <entry>1</entry>
                                <entry>SOH</entry>
                                <entry>DC1</entry>
                                <entry>!</entry>
                                <entry>1</entry>
                                <entry>A</entry>
                                <entry>Q</entry>
                                <entry>a</entry>
                                <entry>q</entry>
                            </row>
                            <row>
                                <entry>2</entry>
                                <entry>STX</entry>
                                <entry>DC2</entry>
                                <entry>"</entry>
                                <entry>2</entry>
                                <entry>B</entry>
                                <entry>R</entry>
                                <entry>b</entry>
                                <entry>r</entry>
                            </row>
                            <row>
                                <entry>3</entry>
                                <entry>ETX</entry>
                                <entry>DC3</entry>
                                <entry>#</entry>
                                <entry>3</entry>
                                <entry>C</entry>
                                <entry>S</entry>
                                <entry>c</entry>
                                <entry>s</entry>
                            </row>
                            <row>
                                <entry>4</entry>
                                <entry>EOT</entry>
                                <entry>DC4</entry>
                                <entry>$</entry>
                                <entry>4</entry>
                                <entry>D</entry>
                                <entry>T</entry>
                                <entry>d</entry>
                                <entry>t</entry>
                            </row>
                            <row>
                                <entry>5</entry>
                                <entry>ENQ</entry>
                                <entry>NAK</entry>
                                <entry>%</entry>
                                <entry>5</entry>
                                <entry>E</entry>
                                <entry>U</entry>
                                <entry>e</entry>
                                <entry>u</entry>
                            </row>
                            <row>
                                <entry>6</entry>
                                <entry>ACK</entry>
                                <entry>SYN</entry>
                                <entry>&amp;</entry>
                                <entry>6</entry>
                                <entry>F</entry>
                                <entry>V</entry>
                                <entry>f</entry>
                                <entry>v</entry>
                            </row>
                            <row>
                                <entry>7</entry>
                                <entry>BEL</entry>
                                <entry>ETB</entry>
                                <entry>'</entry>
                                <entry>7</entry>
                                <entry>G</entry>
                                <entry>W</entry>
                                <entry>g</entry>
                                <entry>w</entry>
                            </row>
                            <row>
                                <entry>8</entry>
                                <entry>BS</entry>
                                <entry>CAN</entry>
                                <entry>(</entry>
                                <entry>8</entry>
                                <entry>H</entry>
                                <entry>X</entry>
                                <entry>h</entry>
                                <entry>x</entry>
                            </row>
                            <row>
                                <entry>9</entry>
                                <entry>HT</entry>
                                <entry>EM</entry>
                                <entry>)</entry>
                                <entry>9</entry>
                                <entry>I</entry>
                                <entry>Y</entry>
                                <entry>i</entry>
                                <entry>y</entry>
                            </row>
                            <row>
                                <entry>A</entry>
                                <entry>LF</entry>
                                <entry>SUB</entry>
                                <entry>*</entry>
                                <entry>:</entry>
                                <entry>J</entry>
                                <entry>Z</entry>
                                <entry>j</entry>
                                <entry>z</entry>
                            </row>
                            <row>
                                <entry>B</entry>
                                <entry>VT</entry>
                                <entry>ESC</entry>
                                <entry>+</entry>
                                <entry>;</entry>
                                <entry>K</entry>
                                <entry>[</entry>
                                <entry>k</entry>
                                <entry>{</entry>
                            </row>
                            <row>
                                <entry>C</entry>
                                <entry>FF</entry>
                                <entry>FS</entry>
                                <entry>,</entry>
                                <entry>&lt;</entry>
                                <entry>L</entry>
                                <entry>\</entry>
                                <entry>l</entry>
                                <entry>|</entry>
                            </row>
                            <row>
                                <entry>D</entry>
                                <entry>CR</entry>
                                <entry>GS</entry>
                                <entry>-</entry>
                                <entry>=</entry>
                                <entry>M</entry>
                                <entry>]</entry>
                                <entry>m</entry>
                                <entry>}</entry>
                            </row>
                            <row>
                                <entry>E</entry>
                                <entry>SO</entry>
                                <entry>RS</entry>
                                <entry>.</entry>
                                <entry>&gt;</entry>
                                <entry>N</entry>
                                <entry>^</entry>
                                <entry>n</entry>
                                <entry>~</entry>
                            </row>
                            <row>
                                <entry>F</entry>
                                <entry>SI</entry>
                                <entry>US</entry>
                                <entry>/</entry>
                                <entry>?</entry>
                                <entry>O</entry>
                                <entry>_</entry>
                                <entry>o</entry>
                                <entry>DEL</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                </para>
            <para><info><itermset>
                <indexterm zone="def_character_encoding">
                    <primary>Unicode</primary>
                    <secondary>character encoding</secondary>
                </indexterm><indexterm significance="preferred"
                    zone="def_glyph">
                    <primary>glyph</primary>
                </indexterm><indexterm zone="def_glyph">
                    <primary>language</primary>
                    <secondary>character</secondary>
                    <tertiary>glyph</tertiary>
                </indexterm><indexterm zone="def_glyph">
                    <primary>Unicode</primary>
                    <secondary>font</secondary>
                    <tertiary>glyph</tertiary>
                </indexterm><indexterm significance="preferred" zone="def_font">
                    <primary>font</primary>
                </indexterm><indexterm zone="def_font">
                    <primary>Unicode</primary>
                    <secondary>font</secondary>
                </indexterm></itermset>
        </info><phrase role="statement">The most ambitious character coding in
                    existence is Unicode, which as of version 6.0 assigns numbers to 109,449
                    characters.</phrase><footnote xml:id="endnote-475" label="552"
                    audience="Computing">
                        <para audience="Computing" xml:id="para-inw_q4r_lr"><info>
                            <itermset>
                                <indexterm audience="Markup" zone="endnote-475">
                                    <primary>endnote</primary>
                                    <secondary>Computing</secondary>
                                </indexterm>
                                <indexterm zone="endnote-475">
                                    <primary>computing</primary>
                                    <secondary>Unicode</secondary>
                                </indexterm>
                            </itermset>
                        </info>The Unicode standard is maintained by a global non-profit
                        organization. Everything you need to know is at <link
                            xmlns:xlink="http://www.w3.org/1999/xlink"
                            xlink:href="http://www.unicode.org/"
                            ><uri>http://www.unicode.org/</uri></link>.</para>
                </footnote>
                <phrase role="definition" xml:id="def_character">Unicode makes the important
                    distinction between <glossterm xreflabel="characters">characters</glossterm> and
                        <glossterm linkend="gloss_glyph">glyphs</glossterm>. A <glossterm
                        xml:id="term_character">character</glossterm> is the smallest meaningful
                    unit of a written language. In alphabet-based languages like English, <glossterm
                        linkend="gloss_character">characters</glossterm> are letters; in languages
                    like Chinese, characters are ideographs.</phrase> Unicode treats all of these
                    <glossterm linkend="gloss_character">characters</glossterm> as abstract ideas
                    (<emphasis>Latin capital A</emphasis>) rather than specific marks (A
                    <emphasis>A</emphasis>
                <literal>A</literal>
                <emphasis role="bold">A</emphasis>). 
                <phrase role="definition" xml:id="def_glyph">A specific mark that can be
                    used to depict a <glossterm linkend="gloss_character">character</glossterm> is a
                        <glossterm xml:id="term_glyph">glyph</glossterm>.</phrase>
                <phrase role="definition" xml:id="def_font">A <glossterm
                        xreflabel="font" xml:id="term_font">font</glossterm> is a collection of
                    glyphs used to depict some set of <glossterm linkend="gloss_character"
                        >characters</glossterm>. A Unicode font explicitly associates each glyph
                    with a particular number in the Unicode character encoding.</phrase> The
                inability of computers to use contextual understanding to bridge the gap between
                various glyphs and the abstract <glossterm linkend="gloss_character"
                    >character</glossterm> depicted by those glyphs turns out to have important
                consequences for organizing systems.</para>
            <para audience="CORE" role="comparative" xml:id="para-jqw_q4r_lr"><info>
                    <itermset>
                        <indexterm zone="para-jqw_q4r_lr">
                            <primary>number sign, #</primary>
                        </indexterm>
                        <indexterm zone="para-jqw_q4r_lr">
                            <primary>music</primary>
                            <secondary>accidentals notation, <symbol>&#9839;</symbol></secondary>
                        </indexterm>
                        <indexterm zone="para-jqw_q4r_lr">
                            <primary>sharp sign, <symbol>&#9839;</symbol></primary>
                        </indexterm>
                    </itermset>
                </info><phrase role="statement">Different notations may include very similar
                    marks.</phrase> For example, modern music notation includes marks for indicating
                the pitch of note, known as accidentals. One of these music notation marks is
                    <symbol>&#9839;</symbol> (<quote>sharp</quote>). The sharp sign looks very much
                like the symbol used in English as an abbreviation for the word
                    <emphasis>number</emphasis>, as in <emphasis>We<symbol>&#8217;</symbol>re
                    #1!</emphasis><footnote xml:id="endnote-476" label="553" audience="Linguistics">
                    <para audience="Linguistics" xml:id="para-ktw_q4r_lr"><info>
                            <itermset>
                                <indexterm audience="Markup" zone="endnote-476">
                                    <primary>endnote</primary>
                                    <secondary>Linguistics</secondary>
                                </indexterm>
                                <indexterm zone="endnote-476">
                                    <primary>linguistics</primary>
                                    <secondary>pound sign</secondary>
                                </indexterm>
                                <indexterm zone="endnote-476">
                                    <primary>pound sign</primary>
                                    <secondary>weight, #</secondary>
                                </indexterm>
                                <indexterm zone="endnote-476">
                                    <primary>hash sign, #</primary>
                                </indexterm>
                                <indexterm zone="endnote-476">
                                    <primary>water well (Chinese)</primary>
                                </indexterm>
                            </itermset>
                        </info>The Chinese character <emphasis><symbol>&#20117;</symbol></emphasis>
                        (water well) looks like the # character too. The # symbol was historically
                        used to denote pounds, the Imperial unit of weight, as in 10# of potatoes.
                        In the United Kingdom, the # character is called<quote>hash.</quote> We
                        could go on, but we will leave it to you to discover more.</para>
                </footnote> If you were to write a sharp sign and a number sign by hand, they would
                probably look identical. In a non-digital environment, we would rely on context to
                understand whether the written mark was being used as part of music notation, or
                mathematical notation, or as an English abbreviation.</para>
            <note userlevel="Editor" revision="4.0" revisionflag="added">
                <title>Editors' Note</title>
                <para xml:id="para-gvn_5bn_3v">Add discussion of numbers, non-numbers, numeric
                    identifiers, representation of numbers, numeric data types. Discuss the
                    importance of assigning the right data type to minimize storage requirements and
                    to suit computational needs. Discuss the pitfalls of using string storage for
                    numeric values. Discuss the use of numeric identifiers (e.g., apartment
                    numbers); relate that numeric operations (e.g., average) are meaningless in
                    these mismatched datatype contexts.</para>
            </note>
            <para audience="CORE" role="contrast" xml:id="para-oww_q4r_lr"><phrase role="statement"
                    >Computers, however, have no such intuitive understanding of context.</phrase>
                Unicode encodes the number sign and the sharp sign as two different characters. As
                far as a computer using Unicode is concerned, <symbol>&#9839;</symbol> and # are
                completely different, and the fact that they have similar-looking glyphs is
                irrelevant. That is a problem if, for example, a cataloger has carefully described a
                piece of music by correctly using the sharp sign, but a person looking for that
                piece of music searches for descriptions using the number sign (since that is what
                you get when you press the keyboard button with the symbol that most closely
                resembles a sharp sign).<footnote xml:id="endnote-477" label="554"
                    audience="Computing">
                    <para audience="Computing" xml:id="para-kzw_q4r_lr"><info>
                            <itermset>
                                <indexterm audience="Markup" zone="endnote-477">
                                    <primary>endnote</primary>
                                    <secondary>Computing</secondary>
                                </indexterm>
                                <indexterm zone="endnote-477">
                                    <primary>pound sign</primary>
                                    <secondary>ASCII vs BS 4730</secondary>
                                </indexterm>
                                <indexterm zone="endnote-477">
                                    <primary>pound sign</primary>
                                    <secondary>currency, <symbol>&#163;</symbol></secondary>
                                </indexterm>
                                <indexterm zone="endnote-477">
                                    <primary>ASCII</primary>
                                </indexterm>
                                <indexterm zone="endnote-477">
                                    <primary>computing</primary>
                                    <secondary>ASCII vs BS 4730</secondary>
                                </indexterm>
                            </itermset>
                        </info>To add to the confusion, while the American standard (<abbrev
                            xreflabel="ASCII">ASCII</abbrev>) places the # character at position 23,
                        the British equivalent (<citerefentry><refentrytitle>BS
                            4730</refentrytitle></citerefentry>) places the currency symbol
                            <symbol>&#163;</symbol> at the same position. As a result, improperly
                        configured computers sometimes display # in place of <symbol>&#163;</symbol>
                        and vice versa.</para>
                </footnote></para>
            <note userlevel="Editor" revision="4.0" revisionflag="added">
                <title>Editors' Note</title>
                <para xml:id="para-wqt_kbn_3v">Add discussion of date/time. Mention Time zones, ISO
                    Date/Time. Discuss the value of date/time math computation in time-series
                    statistical analysis. Ad-hoc date/time entry into a string field(s) jeopardizes
                    a timestamp's initial reliability and its subsequent usefulness in computation.
                </para>
            </note>
        </section>
        <!--              -->
        <section xml:id="section-9.3.2" label="9.3.2">
            <title>Writing Systems</title>
            <info>
                <itermset>
                    <indexterm zone="section-9.3.2">
                        <primary>writing system</primary>
                        <secondary>in resource description</secondary>
                    </indexterm>
                    <indexterm zone="section-9.3.2">
                        <primary>resource description</primary>
                        <secondary>form</secondary>
                        <tertiary>writing system</tertiary>
                    </indexterm></itermset>
        </info>

            <para audience="CORE" xml:id="para-hcx_q4r_lr"><phrase role="definition"
                    xml:id="def_writing_system">A <glossterm xreflabel="writing system"
                        xml:id="term_writing_system">writing system</glossterm> employs one or more
                    notations, and adds a set of rules for using them. Most writing systems assume
                    knowledge of a particular human language. These writing systems are known as
                        <emphasis>glottic</emphasis> writing systems. But there are many writing
                    systems, such as mathematical and musical ones, that are not tied to human
                    languages in this way. Many of the writing systems used for describing resources
                    belong to this latter group, meaning that (at least in principle) they can be
                    used with equal facility by speakers of any language.</phrase></para>
            <para audience="Linguistics" xml:id="para-ffx_q4r_lr"><info><itermset>
                <indexterm zone="para-ffx_q4r_lr">
                    <primary>constraints</primary>
                    <secondary>writing system</secondary>
                </indexterm></itermset>
        </info><phrase role="statement">Glottic writing systems, being grounded in
                    natural human languages, are difficult to describe precisely and
                    comprehensively. Non-glottic writing systems, on the other hand, can be
                    described precisely and comprehensively using an abstract model.</phrase> That
                is the connection between the structural perspective taken in the previous section,
                and the textual perspective taken in this section. A non-glottic writing system is
                described by a particular metamodel, and structures that fit within the constraints
                of a given metamodel can be textually represented using one or more writing systems
                that are described by that metamodel.</para>
            <para audience="CORE" xml:id="para-g3x_q4r_lr"><phrase role="statement">Some writing
                    systems are closely identified with specific metamodels.</phrase> For example,
                    <abbrev>XML</abbrev> and <abbrev>JSON</abbrev> are <emphasis>both</emphasis> 1)
                metamodels for structuring information <emphasis>and</emphasis> 2) writing systems
                for textually representing information. In other words, they specify both the
                abstract structure of a description and how to write it down. It is possible to
                conceive of other ways to textually represent the structure of these metamodels, but
                for each of these metamodels just one writing system has been standardized.<footnote
                    xml:id="endnote-478" label="555" audience="Computing">
                    <para audience="Computing" xml:id="para-dlx_q4r_lr"><info>
                            <itermset>
                                <indexterm audience="Markup" zone="endnote-478">
                                    <primary>endnote</primary>
                                    <secondary>Computing</secondary>
                                </indexterm>
                                <indexterm zone="endnote-478">
                                    <primary>EXI</primary>
                                </indexterm>
                                <indexterm zone="endnote-478">
                                    <primary>computing</primary>
                                    <secondary>EXI</secondary>
                                </indexterm>
                            </itermset>
                        </info>Recently, an alternative writing system for
                        <abbrev>XML</abbrev>-structured data has been standardized:
                                <citerefentry><refentrytitle>Efficient XML
                                Interchange</refentrytitle><manvolnum>EXI</manvolnum></citerefentry>.
                        However it is not yet widely used.</para>
                </footnote></para>
            <para audience="CORE" xml:id="para-f4x_q4r_lr"><abbrev>RDF</abbrev>, on the other hand,
                is <emphasis>only</emphasis> a metamodel, not a writing system. <abbrev>RDF</abbrev>
                only defines an abstract structure, not how to write that structure. <phrase
                    role="interrogative">So how do we write information that is structured as
                    RDF?</phrase> It turns out that we have many choices. Unlike
                    <abbrev>XML</abbrev> and <abbrev>JSON</abbrev>, several different writing
                systems for the <abbrev>RDF</abbrev> metamodel have been standardized, including
                N-Triples, Turtle, RDFa, and RDF/XML.<footnote xml:id="endnote-479" label="556"
                    audience="Computing">
                    <para audience="Computing" xml:id="para-erx_q4r_lr"><info>
                            <itermset>
                                <indexterm audience="Markup" zone="endnote-479">
                                    <primary>endnote</primary>
                                    <secondary>Computing</secondary>
                                </indexterm>
                                <indexterm zone="endnote-479">
                                    <primary>computing</primary>
                                    <secondary>RDF/XML</secondary>
                                </indexterm>
                            </itermset>
                        </info>RDF/XML is a bit confusing; it is a writing system that uses
                            <abbrev>XML</abbrev> syntax to textually represent <abbrev>RDF</abbrev>
                        structure. This means that while <abbrev>XML</abbrev> tools can read and
                        write <abbrev>RDF/XML</abbrev>, they cannot manipulate the graph structures
                        it represents, because they were designed to work with
                        <abbrev>XML</abbrev>’s tree structures.</para>
                </footnote> Each of these is a writing system that is abstractly described by the
                    <abbrev>RDF</abbrev> metamodel.</para>
            <para audience="CORE" xml:id="para-h5x_q4r_lr"><info><itermset>
                <indexterm zone="para-h5x_q4r_lr">
                    <primary>Roman numerals</primary>
                </indexterm></itermset>
        </info><phrase role="statement">Writing systems provide rules for arranging
                    characters from a notation into meaningful structures. A character in a notation
                    has no inherent meaning. Characters in a notation only take on meaning in the
                    context of a writing system that uses that notation.</phrase>
                <phrase role="interrogative">For example: what does the letter
                            <emphasis><symbol>I</symbol></emphasis> from the Latin alphabet
                    mean?</phrase> That question can only be answered by looking at how it is being
                used in a particular writing system. If the writing system is American English, then
                whether <emphasis><symbol>I</symbol></emphasis> has a meaning depends on whether it
                is grouped with other letters or whether it stands alone. Only in the latter case
                does it have an assignable meaning. However in the arithmetic writing system of
                ancient Rome, which also uses as a notation the letters of the Latin alphabet,
                        <emphasis><symbol>I</symbol></emphasis> has a different meaning:
                    <emphasis>one</emphasis>.</para>

            <?need 8cm ?>
            <para audience="CORE" xml:id="para-tyx_q4r_lr"><info>
                    <itermset>
                        <indexterm zone="para-tyx_q4r_lr">
                            <primary>alphabetical ordering</primary>
                        </indexterm>
                    </itermset>
                </info>This example also serves to illustrate how the ordering of a notation can
                differ from the ordering of a writing system that uses that notation. <phrase
                    role="statement">According to the ordering of the Latin alphabet, the twelfth
                    letter <emphasis><symbol>L</symbol></emphasis> comes before the twenty-second
                    letter <emphasis><symbol>V</symbol></emphasis>. But in the Roman numeric writing
                    system, <emphasis><symbol>V</symbol></emphasis> (the number 5) comes before
                            <emphasis><symbol>L</symbol></emphasis> (the number 50).</phrase> Unless
                we know which ordering we are using, we cannot arrange
                    <emphasis><symbol>L</symbol></emphasis> and
                    <emphasis><symbol>V</symbol></emphasis>
                <quote>in order.</quote><footnote xml:id="endnote-480" label="557"
                    audience="Linguistics">
                    <para audience="Linguistics" xml:id="para-fdy_q4r_lr"><info>
                            <itermset>
                                <indexterm audience="Markup" zone="endnote-480">
                                    <primary>endnote</primary>
                                    <secondary>Linguistics</secondary>
                                </indexterm>
                                <indexterm zone="endnote-480">
                                    <primary>linguistics</primary>
                                    <secondary>roman numerals</secondary>
                                </indexterm>
                                <indexterm zone="endnote-480">
                                    <primary>Roman numerals</primary>
                                </indexterm>
                            </itermset>
                        </info>Although we use alphabetic characters today to represent Roman
                        numerals, originally they were represented by unique symbols.</para>
                </footnote></para>
            <table frame="all" rowsep="1" colsep="1" xml:id="table-roman-numerals">
                <title>Roman Numerals</title>
                <tgroup cols="2" align="center">
                    <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                    <colspec colname="c2" colnum="2" colwidth="1.0*"/>
                    <thead>
                        <row>
                            <entry>Roman Number</entry>
                            <entry>Arabic Number</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>I</entry>
                            <entry>1</entry>
                        </row>
                        <row>
                            <entry>V</entry>
                            <entry>5</entry>
                        </row>
                        <row>
                            <entry>X</entry>
                            <entry>10</entry>
                        </row>
                        <row>
                            <entry>L</entry>
                            <entry>50</entry>
                        </row>
                        <row>
                            <entry>C</entry>
                            <entry>100</entry>
                        </row>
                        <row>
                            <entry>D</entry>
                            <entry>500</entry>
                        </row>
                        <row>
                            <entry>M</entry>
                            <entry>1000</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <para audience="CORE" xml:id="para-pgy_q4r_lr"><info>
                    <itermset>
                        <indexterm zone="para-pgy_q4r_lr">
                            <primary>alphabetical ordering</primary>
                        </indexterm>
                    </itermset>
                </info>This kind of difference in ordering can arise in more subtle ways as well.
                When we alphabetically order names, we first compare the first character of each
                name, and arrange them according to the ordering of the writing system. <phrase
                    role="statement">The first known use of alphabetical ordering was in the Library
                    of Alexandria about two thousand years ago, when
                            <personname><surname>Zenodotus</surname></personname> arranged the
                    collection according to the first letter of resource names.</phrase><footnote
                    xml:id="endnote-481" label="558" audience="Linguistics">
                    <para audience="Linguistics" xml:id="para-xjy_q4r_lr"><info>
                            <itermset>
                                <indexterm audience="Markup" zone="endnote-481">
                                    <primary>endnote</primary>
                                    <secondary>Linguistics</secondary>
                                </indexterm>
                                <indexterm zone="endnote-481">
                                    <primary>linguistics</primary>
                                    <secondary>alphabetic ordering</secondary>
                                </indexterm>
                                <indexterm zone="endnote-481">
                                    <primary>alphabetical ordering</primary>
                                    <secondary>writing system</secondary>
                                </indexterm>
                                <indexterm zone="endnote-481">
                                    <primary>computing</primary>
                                    <secondary>ordering</secondary>
                                </indexterm>
                            </itermset>
                        </info>It took a few hundred years before alphabetization became recursive
                        and applied to letters other than the first <citation
                            xml:id="cite_Casson2002-9.1" linkend="Casson2002">(Casson 2002, p.
                            37)</citation>. Alphabetization relies on the ordering of the writing
                        system, not the notation. For example, Swedish and German are two writing
                        systems that assign different orderings to the same notation.</para>
                </footnote> If the first characters of two names are the same, we compare the second
                character, and so on. We can also apply this same kind of ordering procedure to
                sequences of numerals. If we do, then <emphasis>334</emphasis> will come before
                    <emphasis>67</emphasis>, because <emphasis>3</emphasis> (the first character of
                the first sequence) comes before <emphasis>6</emphasis> (the first character of the
                second sequence) according to the ordering of our notation (Arabic numerals).
                However, it is more common when ordering sequences of numerals to treat them as
                decimal numbers, and thus to use the ordering imposed by the decimal system. In the
                decimal writing system, <emphasis>67</emphasis> precedes <emphasis>334</emphasis>,
                since the latter is a greater number.</para>
            <para audience="CORE" xml:id="para-ymy_q4r_lr"><info><itermset>
                <indexterm zone="para-ymy_q4r_lr">
                <primary>LOC-CN</primary>
                </indexterm><indexterm zone="para-ymy_q4r_lr">
                <primary>call numbers</primary>
            </indexterm></itermset>
        </info>This difference is important for
                organizing systems. <phrase role="statement">Computers will sort values differently
                    depending on whether they are treating sequences of numerals as numbers or just
                    as sequences.</phrase> Some organizing systems mix multiple ways of ordering the
                same characters. For example, <orgname>Library of Congress</orgname>
                call numbers have four parts, and sequences of Arabic numerals can
                appear in three of them. In the second part, indicating a narrow subject area, and
                fourth part, indicating year of publication, sequences of numerals are treated as
                numbers and ordered according to the decimal system. In the third part, however,
                sequences of numerals are treated as sequences and ordered
                    <quote>notationally</quote> as in the example above (<emphasis>334</emphasis>
                before <emphasis>67</emphasis>).</para>
            <para audience="CORE" xml:id="para-cqy_q4r_lr"><phrase role="statement">Differences in
                    ordering demonstrate just one way that multiple writing systems may use the same
                    notation differently. For example, the American English and British English
                    writing systems both use the same Latin alphabet, but impose slightly different
                    spelling rules.</phrase><footnote xml:id="endnote-482" label="559"
                    audience="Linguistics">
                    <para audience="Linguistics" xml:id="para-fty_q4r_lr"><info>
                            <itermset>
                                <indexterm audience="Markup" zone="endnote-482">
                                    <primary>endnote</primary>
                                    <secondary>Linguistics</secondary>
                                </indexterm>
                                <indexterm zone="endnote-482">
                                    <primary>linguistics</primary>
                                    <secondary>spelling</secondary>
                                </indexterm>
                            </itermset>
                        </info>For example, the American spelling of the words <quote>center</quote>
                        and <quote>color</quote> contrasts slightly with the English spelling of
                            <quote>centre</quote> and <quote>colour.</quote> There are too many
                        examples to include here. Wikipedia has a comprehensive analysis of American
                        and British spelling differences at <link
                            xmlns:xlink="http://www.w3.org/1999/xlink"
                            xlink:href="http://en.wikipedia.org/wiki/American_and_British_English_spelling_differences"
                                ><uri>http://en.wikipedia.org/wiki/American_and_British_English_spelling_differences</uri></link>.</para>
                </footnote> The Japanese writing system employs a number of notations, including
                traditional Chinese characters (<emphasis>kanji</emphasis>) as well as the Latin
                alphabet (<emphasis>r&#333;maji</emphasis>). <phrase role="statement">Often, writing
                    systems do not share the same exact notation but have mostly overlapping
                    notations. Many European languages, for example, extend the Latin alphabet with
                    characters such as <emphasis><symbol>&#197;</symbol></emphasis> and
                            <emphasis><symbol>&#220;</symbol></emphasis> that add additional marks,
                    known as diacritics, to the basic characters.</phrase><footnote
                    xml:id="endnote-483" label="560" audience="Computing">
                    <para audience="Computing" xml:id="para-gwy_q4r_lr"><info>
                            <itermset>
                                <indexterm audience="Markup" zone="endnote-483">
                                    <primary>endnote</primary>
                                    <secondary>Computing</secondary>
                                </indexterm>
                                <indexterm zone="endnote-483">
                                    <primary>ASCII</primary>
                                </indexterm>
                                <indexterm zone="endnote-483">
                                    <primary>computing</primary>
                                    <secondary>character encodings</secondary>
                                </indexterm>
                                <indexterm zone="endnote-483">
                                    <primary>character</primary>
                                    <secondary>encoding</secondary>
                                </indexterm>
                            </itermset>
                        </info><abbrev xreflabel="ASCII">ASCII</abbrev>’s 128 characters are
                        insufficient to represent these more complex character sets, so a new family
                        of character encodings was created, ISO-8859, in which each encoding
                        enumerates 256 characters. Each encoding thus has more space to accommodate
                        the additional characters of regionally-specific notations. ISO 8859-5, for
                        example, has extensions to support the Cyrillic alphabet.</para>
                </footnote></para>
            <para audience="CORE" xml:id="para-hzy_q4r_lr"><info><itermset>
                <indexterm zone="para-hzy_q4r_lr">
                    <primary>ASCII</primary>
                </indexterm></itermset>
        </info><phrase role="statement">In organizing systems it is often necessary to
                    represent values from one writing system in another writing system that uses a
                    different notation, a process known as
                    <emphasis>transliteration</emphasis>.</phrase> For example, early computer
                systems only supported the <abbrev>ASCII</abbrev> notation, so text from writing
                systems that extend the Latin alphabet had to be converted to
                <abbrev>ASCII</abbrev>, usually by removing (or sometimes transliterating)
                diacritics. This made the non-<abbrev>ASCII</abbrev> text usable in an <abbrev
                    xreflabel="ASCII">ASCII</abbrev>-based computerized organizing system, at the
                expense of information loss.</para>
            <para audience="CORE" xml:id="para-mcz_q4r_lr">Even in modern computer systems that
                support Unicode, however, transliteration is often needed to support organizing
                activities by users who cannot read text written using its original system. <phrase
                    role="statement">The <orgname>Library of Congress</orgname> and the
                        <orgname>American Library Association</orgname> provide standard procedures
                    for transliterating text from over sixty different writing systems into the
                    (extended) Latin alphabet.</phrase></para>
        </section>
        <!--              -->
        <?need 6cm ?>
        <section xml:id="section-9.3.3" label="9.3.3">
            <title>Syntax</title>
            <info>
                <itermset>
                    <indexterm zone="section-9.3.3">
                        <primary>syntax</primary>
                    </indexterm>
                    <indexterm zone="section-9.3.3">
                        <primary>resource description</primary>
                        <secondary>form</secondary>
                        <tertiary>syntax</tertiary>
                    </indexterm></itermset>
        </info>

            <para audience="CORE" xml:id="para-w2z_q4r_lr"><info>
                    <itermset>
                        <indexterm zone="para-w2z_q4r_lr">
                            <primary>ASCII</primary>
                        </indexterm>
                    </itermset>
                </info>The examples in <xref linkend="example-9-5"/> express the same
                information using different writing systems. The examples use the same notation
                    (<abbrev xreflabel="ASCII">ASCII</abbrev>) but differ in their <glossterm
                    linkend="gloss_syntax" xreflabel="syntax">syntax</glossterm>: the rules that
                define how characters can be combined into words and how words can be combined into
                higher-level structures.<footnote xml:id="endnote-484" label="561"
                    audience="Computing">
                    <para audience="Computing" xml:id="para-rhz_q4r_lr"><info>
                            <itermset>
                                <indexterm audience="Markup" zone="endnote-484">
                                    <primary>endnote</primary>
                                    <secondary>Computing</secondary>
                                </indexterm>
                                <indexterm zone="endnote-484">
                                    <primary>computing</primary>
                                    <secondary>syntax</secondary>
                                </indexterm>
                            </itermset>
                        </info>In discussions of glottic writing systems, <quote>syntax</quote>
                        usually refers only to the rules for combining words into sentences. In
                        discussions of programming languages, <quote>syntax</quote> has the broader
                        sense we use here.</para>
                </footnote></para>
            <itemizedlist>
                <listitem>

                    <para audience="CORE" xml:id="para-rkz_q4r_lr">Consider the first entry:
                            <emphasis>The title is</emphasis> Die Ringe des Saturn <emphasis>and it
                            has 371 pages</emphasis>. The leading capital letter and the period
                        ending this sequence of characters indicate to us that this is a sentence.
                        This sentence is one way we might use the English writing system to express
                        two statements about the book we are describing. A
                            <emphasis>statement</emphasis> is one distinct fact or piece of
                        information. In glottic writing systems like English, there is usually more
                        than one sentence we could write to express the same statement. For example,
                        instead of <emphasis>it has 371 pages</emphasis> we might have written
                            <emphasis>the number of pages is 371</emphasis>. <phrase
                            role="statement">English writing also enables us to construct complex
                            sentences that express more than one statement.</phrase><footnote
                            xml:id="endnote-485" label="562" audience="Linguistics">
                            <para audience="Linguistics" xml:id="para-vnz_q4r_lr"><info>
                                    <itermset>
                                        <indexterm audience="Markup" zone="endnote-485">
                                            <primary>endnote</primary>
                                            <secondary>Linguistics</secondary>
                                        </indexterm>
                                        <indexterm zone="endnote-485">
                                            <primary>compound sentences</primary>
                                        </indexterm>
                                        <indexterm zone="endnote-485">
                                            <primary>linguistics</primary>
                                            <secondary>compound sentences</secondary>
                                        </indexterm>
                                    </itermset>
                                </info>Compound sentences contain two independent clauses joined by
                                a conjunction, such as <quote>and,</quote>
                                <quote>or,</quote>
                                <quote>nor,</quote>
                                <quote>but.</quote> For example: I went to the store and I bought a
                                    book.<symbol>&#8221;</symbol> Complex sentences contain an
                                independent clause joined by one or more dependent clauses. For
                                example: <quote>I read the book that I bought at the
                                store.</quote></para>
                        </footnote></para>
                    


                    <para audience="CORE" role="contrast" xml:id="para-wqz_q4r_lr">In contrast, when
                        we create descriptions of resources in an organizing system, we generally
                        use non-glottic writing systems in which each sentence only expresses a
                        single statement, and there is just one way to write a sentence that
                        expresses a given statement.<footnote xml:id="endnote-486" label="563"
                            audience="Computing">
                            <para audience="Computing" xml:id="para-rtz_q4r_lr"><info>
                                    <itermset>
                                        <indexterm audience="Markup" zone="endnote-486">
                                            <primary>endnote</primary>
                                            <secondary>Computing</secondary>
                                        </indexterm>
                                        <indexterm zone="endnote-486">
                                            <primary>computing</primary>
                                            <secondary>non-glottic writing systems</secondary>
                                        </indexterm>
                                    </itermset>
                                </info>In truth, even non-glottic writing systems designed to encode
                                resource descriptions unambiguously can have variant forms of the
                                same statement. For example, <abbrev>XML</abbrev> permits some
                                variation in the way the same Infoset may be textually represented.
                                Often these variations involve the treatment of content that may
                                under some circumstances be treated as optional, such as white
                                space. The difference is that in writing systems designed for
                                resource description, these variations can be precisely enumerated
                                and rules developed to reconcile them, while this is not generally
                                true for glottic writing systems.</para>
                        </footnote> These restrictions make these writing systems less expressive,
                        but simplify their use. In particular, since there is a one-to-one
                        correspondence between sentences and statements, we can drop the distinction
                        and just talk about the statements of a description.</para>

                    <para audience="CORE" xml:id="para-hwz_q4r_lr">Now we return to our example and
                        look at the structure of the statement, <emphasis>The title is</emphasis>
                        Die Ringe des Saturn <emphasis>and it has 371 pages</emphasis>. Spaces are
                        used to separate the text into words, and English syntax defines the
                        functions of those words. The verb <emphasis>is</emphasis> in this statement
                        functions to link the word <emphasis>title</emphasis> to the phrase
                            <emphasis>Die Ringe des Saturn</emphasis>. This is typical of the kind
                        of statements found in a resource description. Each statement identifies and
                        describes some aspect of the resource. In this case, the statement
                        attributes the value <emphasis>Die Ringe des Saturn</emphasis> to the
                        property <emphasis>title</emphasis>.</para>
                    <para audience="CORE" xml:id="para-nzz_q4r_lr">As we saw when we looked at
                        description structures, we can analyze descriptions as involving properties
                        of resources and their corresponding values or content. In a writing system
                        like English, it is not always so straightforward to determine which words
                        refer to properties and which refer to values. (This is why blobs are not
                        ideal description structures.) Writing systems designed for expressing
                        resource descriptions, on the other hand, usually define syntax that makes
                        this determination easier. In our dictionary examples above, we used an
                        arrow character <symbol>&#8594;</symbol> to indicate the relationship
                        between properties and values.</para>
                    <para audience="CORE" xml:id="para-vc1_r4r_lr">This ease of distinguishing
                        properties and values comes at a price, however. The syntax of English is
                        forgiving: we can read a sentence with somewhat garbled syntax such as
                            <emphasis>371 pages it has</emphasis> and often still make out its
                            meaning.<footnote xml:id="endnote-487" label="564"
                            audience="Linguistics">
                            <para audience="Linguistics" xml:id="para-wf1_r4r_lr"><info>
                                    <itermset>
                                        <indexterm audience="Markup" zone="endnote-487">
                                            <primary>endnote</primary>
                                            <secondary>Linguistics</secondary>
                                        </indexterm>
                                        <indexterm zone="endnote-487">
                                            <primary>cognitive science</primary>
                                            <secondary>English to Yoda</secondary>
                                        </indexterm>
                                        <indexterm zone="endnote-487">
                                            <primary>linguistics</primary>
                                            <secondary>English to Yoda</secondary>
                                        </indexterm>
                                    </itermset>
                                </info>Fortunately for Yoda. There are many web services for
                                converting English to Yoda-speak; an example is <link
                                    xmlns:xlink="http://www.w3.org/1999/xlink"
                                    xlink:href="http://www.yodaspeak.co.uk/"
                                        ><uri>http://www.yodaspeak.co.uk/</uri></link>.</para>
                        </footnote> This is usually not the case with writing systems intended for
                        expressing resource descriptions. These systems strictly define their rules
                        for how characters can be combined into higher-level structures. Structures
                        that follow the rules are <glossterm linkend="gloss_well-formed">well
                            formed</glossterm> according to that system.</para>
                </listitem>
                <listitem>

                    <para audience="CORE" xml:id="para-z31_r4r_lr">Take for example the second entry
                        in <xref xrefstyle="short" linkend="example-9-5"/>.
                        <programlisting>{ book: {"title":"Die Ringe des Saturn","pages":371} }</programlisting>This
                        fragment is written in <abbrev>JSON</abbrev>. As explained earlier in this
                        chapter, <abbrev>JSON</abbrev> is a metamodel for structuring information
                        using lists and dictionaries. But <abbrev>JSON</abbrev> is also a writing
                        system, which borrows its syntax from JavaScript. The <abbrev>JSON</abbrev>
                        syntax uses brackets to textually represent lists <literal>[1,2,3]</literal>
                        and braces to textually represent dictionaries <literal>{title:"Die Ringe
                            des Saturn", "pages":371}</literal>. Within braces, the colon character
                            <literal>:</literal> is used to link properties with their values, much
                        as is was used in the previous example. So <literal>"pages":371</literal> is
                        a statement assigning the value <literal>371</literal> to the property
                            <literal>pages</literal>.</para>
                </listitem>
                <listitem>

                    <para audience="CORE" xml:id="para-xl1_r4r_lr">The third fragment is written in
                            <abbrev>XML</abbrev>.
                        <programlisting>&lt;book pages="371"&gt; &lt;title&gt;Die Ringe des Saturn&lt;/title&gt; &lt;/book&gt;</programlisting>Like
                            <abbrev>JSON</abbrev>, <abbrev>XML</abbrev> is a metamodel and also a
                        writing system. Here we have <abbrev>XML</abbrev> elements and attributes.
                            <abbrev>XML</abbrev> elements are textually represented as
                            <emphasis>tags</emphasis> that are marked using the special characters
                            <literal>&lt;</literal>, <literal>&gt;</literal> and
                            <literal>/</literal>. So, this fragment of <abbrev>XML</abbrev> consists
                        of a <literal>book</literal> element with a child element,
                            <literal>title</literal>, and a <literal>pages</literal> attribute, each
                        of which has some text content. In this case, <literal>pages="371"</literal>
                        is a statement assigning the value 371 to the property
                            <literal>pages</literal>. The difference is syntax is subtle; quotation
                        marks surround the value and equal sign = is used to assign the property to
                        its value.</para>
                </listitem>
                <listitem>

                    <para audience="CORE" xml:id="para-x41_r4r_lr">The fourth is a fragment of
                            <abbrev>HTML</abbrev>.
                        <programlisting>&lt;div class="book"&gt;The title is 
&lt;span class="title"&gt;Die Ringe des Saturn&lt;/span&gt;
and it has &lt;span class="pages"&gt;371 pages.&lt;/span&gt;
&lt;/div&gt;</programlisting>The
                        writing system that <abbrev>HTML</abbrev> employs is close enough to
                            <abbrev>XML</abbrev> to ignore any differences in syntax. In this
                        example, the CLASS attribute contains the property name and the property
                        value is the element content.</para>
                </listitem>
                <listitem>

                    <para audience="CORE" xml:id="para-zr1_r4r_lr">The fifth entry is a fragment of
                        Turtle, one of the writing systems for <abbrev>RDF</abbrev>.
                        <programlisting>&lt;http://lccn.loc.gov/96103072&gt;
&lt;http://rdvocab.info/Elements/title&gt; "Die Ringe des Saturn"@de ;
&lt;http://rdvocab.info/Elements/extentOfText&gt; "371 p." .</programlisting>Turtle
                        provides a syntax for writing down <abbrev>RDF</abbrev>
                        <glossterm linkend="gloss_triple">triples</glossterm>. Each triple consists
                        of a subject, predicate, and object separated by spaces. Recall that
                            <abbrev>RDF</abbrev> uses <abbrev>URI</abbrev>s to identify subjects,
                        predicates, and some objects; these <abbrev>URI</abbrev>s are written in
                        Turtle by enclosing them in angle brackets <literal>&lt; &gt;</literal>.
                        Triples are separated by period <literal>.</literal> characters, but triples
                        that share the same subject can be written more compactly by writing the
                        subject only once, and then writing the predicate and object of each triple,
                        separated by a semicolon <literal>;</literal> character. This is what we see
                        in <xref linkend="example-9-2" xreflabel="select: label"/>: two
                        triples that share a subject.</para>
                </listitem>
            </itemizedlist>

            <para audience="CORE" xml:id="para-z51_r4r_lr"><info><itermset>
                <indexterm zone="para-z51_r4r_lr">
                    <primary>DC</primary>
                </indexterm><indexterm zone="para-z51_r4r_lr">
                    <primary>DCMI</primary>
                </indexterm></itermset>
        </info>The two fragments in <xref linkend="example-9-6"/> demonstrate
                namespaces, terms from the Dublin Core and DocBook namespaces, and the facility with
                which <abbrev>XML</abbrev> embraces semantic encoding of description resources.
                    <example xml:id="example-9-6" label="9.6" audience="CORE">
                    <title>Writing part of a book description in Semantic XML.</title>
                    <info>
                        <itermset>
                            <indexterm zone="example-9-6">
                                <primary>resource description</primary>
                                <secondary>form</secondary>
                                <tertiary>XML</tertiary>
                            </indexterm></itermset>
        </info>
                    <informaltable>
                        <tgroup cols="1">
                            <colspec colnum="1" colname="c1" rowsep="1"/>
                            <tbody>
                                <row>
                                    <entry>
                                        <programlisting xml:id="pro_id00004" linenumbering="unnumbered">&lt;book xmlns:dc="http://purl.org/dc/terms/" dc:extent="371 p."&gt;
&lt;dc:title&gt;Die Ringe des Saturn&lt;/title&gt;
...
&lt;/book&gt;</programlisting>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <programlisting>&lt;book xmlns:db="http://www.docbook.org/xml/4.5/docbookx.dtd"&gt;
&lt;bookinfo&gt;
&lt;title&gt;Die Ringe des Saturn&lt;/title&gt;
&lt;pagenums&gt;371 p.&lt;/pagenums&gt;...&lt;/bookinfo&gt;
...
&lt;/book&gt;</programlisting>
                                    </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                </example>
                <itemizedlist>
                    <listitem>
                        <para audience="CORE" xml:id="para-gy1_r4r_lr">The first example extends the
                            third fragment from <xref xreflabel="select: label"
                                linkend="example-9-5"/>; the
                                    <literal>xmlns:dc="<replaceable>...</replaceable>"</literal>
                            segment is a namespace declaration, which is associating
                                <literal>dc</literal> with the quoted URI, which happens to be the
                                    <citerefentry><refentrytitle>Dublin Core Metadata
                                    Initiative</refentrytitle><manvolnum>DCMI</manvolnum></citerefentry>;
                            the child <tag class="starttag">dc:title</tag> element and the attached
                                <literal>dc:extent="371"</literal> tell us that the corresponding
                            values are attributable to the title and extent properties,
                            respectively, from the Dublin Core namespace. </para>
                    </listitem>
                    <listitem>
                        <para audience="CORE" xml:id="para-gbb_r4r_lr">The next fragment employs
                            DocBook DTD namespace; we now have a <tag class="starttag"
                                >pagenums</tag> element for which the meaning is contextually
                            obvious; the title is still a title; an extra layer of markup reflects
                            the fact that it could be metadata in the source file of a book that is
                            being edited, is in production or is on your favorite tablet right
                                now.<footnote xml:id="endnote-488" label="565" audience="Computing">
                                <para audience="Computing" xml:id="para-f2b_r4r_lr"><info>
                                        <itermset>
                                            <indexterm audience="Markup" zone="endnote-488">
                                                <primary>endnote</primary>
                                                <secondary>Computing</secondary>
                                            </indexterm>
                                            <indexterm zone="endnote-488">
                                                <primary>DocBook</primary>
                                            </indexterm>
                                            <indexterm zone="endnote-488">
                                                <primary>computing</primary>
                                                <secondary>DocBook</secondary>
                                            </indexterm>
                                        </itermset>
                                    </info>DocBook <citation xml:id="cite_Walsh2010-9.1"
                                        linkend="Walsh2010">(Walsh 2010)</citation> is widely used
                                    to publish academic, commercial, industrial book, scientific,
                                    and computing book, papers and articles. The book that you are
                                    reading is encoded with DocBook markup; complete bibliographic
                                    information for the book is contained within the source files,
                                    ready to be extracted on the way into one of the latest ebook
                                    formats.</para>
                            </footnote></para>
                    </listitem>
                </itemizedlist>
            </para>




            <sidebar xml:id="sidebar-microformats" audience="Web IA">
                <title>Microformats, RDFa and Microdata</title>
                <info>
                    <itermset>
                        <indexterm zone="sidebar-microformats" condition="print" userlevel="Professional Graduate">
                            <primary>sidebar</primary>
                            <secondary>Microformats, RDFa and Microdata</secondary>
                        </indexterm>
                        <indexterm zone="sidebar-microformats" userlevel="Professional Graduate">
                            <primary>Microformats, RDFa and Microdata</primary>
                        </indexterm>
                        <indexterm zone="sidebar-microformats">
                            <primary>resource description</primary>
                            <secondary>form</secondary>
                            <tertiary>microformats</tertiary>
                        </indexterm>
                        <indexterm zone="sidebar-microformats">
                            <primary>resource description</primary>
                            <secondary>form</secondary>
                            <tertiary>microdata</tertiary>
                        </indexterm>
                        <indexterm zone="sidebar-microformats">
                            <primary>resource description</primary>
                            <secondary>form</secondary>
                            <tertiary>RDF</tertiary>
                        </indexterm>
                        <indexterm zone="sidebar-microformats">
                            <primary>resource description</primary>
                            <secondary>form</secondary>
                            <tertiary>attributes</tertiary>
                        </indexterm></itermset>
        </info>

                <para audience="CORE" xml:id="para-ghb_r4r_lr"><info><itermset>
                    <indexterm zone="para-ghb_r4r_lr">
                        <primary>Berners-Lee, Tim</primary>
                    </indexterm></itermset>
        </info>When
                            <personname><firstname>Tim</firstname><surname>Berners-Lee</surname></personname>
                    deployed HTML, its syntax contained the basic elements and attributes needed to
                    make formal statements about the document as a whole by using <tag
                        class="emptytag">LINK</tag>, or about specific parts of the document by
                    using the <tag class="starttag">A</tag> element. Each of these elements have
                    four attributes in common: the famous HREF attribute contains a URI that names
                    an object resource; the NAME attribute allows the element to be the target end
                    of a link; the REL and REV attributes contain descriptions of the link
                    relations.</para>
                <para audience="CORE" xml:id="para-jkb_r4r_lr">Microformats, RDFa and Microdata are
                    the latest generation of metadata extensions to HTML. Each approach is widely
                    used on the web and by search engines. As such, they are potential targets when
                    transforming into HTML from richer semantic formats.</para>
                <para audience="CORE" xml:id="para-fnb_r4r_lr">Microformats are the simplest of the
                    three. It uses controlled vocabularies of terms in REL/REV, and in the CLASS
                    attribute, to declare high-level information types.</para>
                <para audience="CORE" xml:id="para-eqb_r4r_lr">RDFa is RDF in Attributes. That is,
                    RDFa is a formal specification for writing RDF expressions by using attributes
                    in <abbrev>XML</abbrev> and <abbrev>HTML</abbrev> documents. It uses an ABOUT
                    attribute to name the subject of the relation; the REL and REV attributes; HREF
                    is joined by SRC and RESOURCE to name the object of the link; a TYPEOF attribute
                    declares a type; PROPERTY and CONTENT attributes are used to <glossterm
                        linkend="gloss_attribute">attribute</glossterm> a value to an object’s
                    property.</para>
                <para audience="CORE" xml:id="para-ftb_r4r_lr">Microdata is similar, inasmuch as it
                    uses attributes extensively. The presence of an ITEMSCOPE attribute identifies
                    an item while the ITEMTYPE attribute value identifies its type; ITEMID declares
                    an items name or unique identifier; ITEMPROP is a name value pair, and; ITEMREF
                    relates this item to other elements that are outside of the scope of the
                    container element.</para>
            </sidebar>


            <para audience="CORE" xml:id="para-fwb_r4r_lr">The two fragments in <xref
                    xrefstyle="short" linkend="example-9-7"/> demonstrate RDFa and microdata
                formats, which each rely upon specific attributes to establish the type of the
                property values contained by the HTML elements. In each example, the book title is
                contained by a <tag class="starttag">span</tag> element. Whereas RDFa relies upon
                the <tag class="attribute">property</tag> attribute, the microdata example employs
                the <tag class="attribute">itemprop</tag> attribute to specify that the contents of
                the element is, effectively, a <quote>title</quote> in exactly the same sense as we
                know that the contents of <tag class="starttag">dc:title</tag> is a
                    <quote>title.</quote>
                <example xml:id="example-9-7" label="9.7" audience="CORE">
                    <title>Writing part of a book description in RDFa or microdata.</title>
                    <info>
                        <itermset>
                            <indexterm zone="example-9-7">
                                <primary>resource description</primary>
                                <secondary>form</secondary>
                                <tertiary>RDF</tertiary>
                            </indexterm>
                            <indexterm zone="example-9-7">
                                <primary>resource description</primary>
                                <secondary>form</secondary>
                                <tertiary>microdata</tertiary>
                            </indexterm></itermset>
        </info>
                    <informaltable>
                        <tgroup cols="1">
                            <colspec colnum="1" colname="c1" rowsep="1"/>
                            <tbody>
                                <row>
                                    <entry>
                                        <programlisting>&lt;div class="book"&gt;The title is
&lt;span property="http://purl.org/dc/terms/title"&gt;Die Ringe des Saturn&lt;/span&gt;
and it has &lt;span property="http://purl.org/dc/terms/extent"&gt;371 p.&lt;/span&gt;&lt;/div&gt;</programlisting>
                                    </entry>
                                </row>
                                <row>
                                    <entry>
                                        <programlisting>&lt;div itemscope itemtype="book"&gt;The title is
&lt;span itemprop="http://purl.org/dc/terms/title"&gt;Die Ringe des Saturn&lt;/span&gt;
and it has &lt;span itemprop="http://purl.org/dc/terms/extent"&gt;371 p.&lt;/span&gt;&lt;/div&gt;</programlisting>
                                    </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                </example>
            </para>
        </section>
        
        <!-- ###################### SECTION ########################################### -->
    </section>
    <!--              -->
    <section xml:id="section-9.4" label="9.4">
        <title>Worlds of Description</title>
        <info>
            <itermset>
                <indexterm zone="section-9.4">
                    <primary>resource description</primary>
                    <secondary>worlds</secondary>
                </indexterm></itermset>
        </info>

        <para audience="CORE" xml:id="para-j4c_r4r_lr"><info><itermset>
            <indexterm zone="para-j4c_r4r_lr">
                <primary>constraints</primary>
                <secondary>environment</secondary>
            </indexterm></itermset>
        </info>In the previous two sections we have considered descriptions as designed
            objects with particular structures and as written documents with particular syntaxes. As
            we have seen, there are many possible choices of structure and syntax. But these choices
            are never made in isolation. Just as an architect or designer must work within the
            constraints of the existing built environment, and just as any author must work with
            existing writing systems, descriptions are always created as part of a pre-existing
                <quote>world</quote> over which any one of us has little control.</para>
        <para audience="CORE" xml:id="para-jrc_r4r_lr">In the final part of this chapter, we will
            consider how choices of structure and syntax have converged historically into broad
            patterns of usage. For lack of a better term, we call these broad patterns
                <quote>worlds.</quote>
            <quote>World</quote> is not a technical term and should not be taken too literally: the
            broad areas of application sketched here have considerable overlap, and there are many
            other ways one might identify patterns of description structure and syntax. That said,
            the three worlds described here do reflect real patterns of description form that
            influence tool and technology choices. In your own work creating and managing resource
            descriptions, it is likely that you will need to think about how your descriptions fit
            into one or more of these worlds.</para>
        <!--              -->
        <section xml:id="section-9.4.1" label="9.4.1">
            <title>The Document Processing World</title>
            <info>
                <itermset>
                    <indexterm zone="section-9.4.1">
                        <primary>document processing</primary>
                    </indexterm>
                    <indexterm zone="section-9.4.1">
                        <primary>resource description</primary>
                        <secondary>form</secondary>
                        <tertiary>XML</tertiary>
                    </indexterm>
                    <indexterm zone="section-9.4.1">
                        <primary>resource description</primary>
                        <secondary>form</secondary>
                        <tertiary>document</tertiary>
                    </indexterm></itermset>
        </info>

            <para audience="CORE" xml:id="para-k5c_r4r_lr">The first world we will consider is
                concerned primarily with the creation, processing and management of hybrid
                narrative-transactional documents such as instruction manuals, textbooks, or
                annotated medieval manuscripts. <phrase role="parenthetical">(See <xref
                        linkend="sidebar-DocTypeSpectrum"/>)</phrase>. These are quite different kinds
                of documents, but they all contain a mixture of narrative text and structured data,
                and they all can be usefully modeled as tree structures. Because of these shared
                qualities, tools as different as publishing software, supply-chain management
                software, and scholarly editing software have all converged on common
                    <abbrev>XML</abbrev>-based solutions. (<quote>The <abbrev>XML</abbrev>
                    world</quote> would be another appropriate name for the document-processing
                world.)</para>
            <para audience="CORE" xml:id="para-jxc_r4r_lr">This convergence was no accident, because
                    <abbrev>XML</abbrev> was designed specifically to address the problem of how to
                add structure and data to documents by <quote>marking them up.</quote>
                <abbrev>XML</abbrev> is the descendant of <citerefentry><refentrytitle>Standard
                        Generalized Markup
                    Language</refentrytitle><manvolnum>SGML</manvolnum></citerefentry>, which in
                turn descended from <citerefentry xml:id="ref_IBM"><refentrytitle>International
                        Business Machines</refentrytitle><manvolnum>IBM</manvolnum></citerefentry>’s
                        <citerefentry><refentrytitle>Generalized Markup
                    Language</refentrytitle></citerefentry>, which was invented to enable the
                production and management of large-scale technical documentation. <phrase
                    role="statement">The explicitness of markup makes it well-suited for
                    representing structure and content type distinctions in institutional contexts,
                    where the scope, scale, and expected lifetime of organizing systems for
                    information implies reuse by unknown people for unanticipated
                purposes.</phrase></para>
            <para audience="Computing IA" xml:id="para-g1d_r4r_lr"><phrase><phrase role="statement"
                        >The abstract data model underlying <abbrev>XML</abbrev> is called the
                                    <citerefentry><refentrytitle><abbrev>XML</abbrev> Information
                                Set</refentrytitle></citerefentry> or Infoset. The Infoset defines a
                        document as a partially ordered tree of <quote>information
                        items.</quote></phrase></phrase>
                <phrase role="statement">Every <abbrev>XML</abbrev> document can thus be understood
                    as a specific kind of tree, although not every tree structure is expressible as
                    an <abbrev>XML</abbrev> document.</phrase><footnote xml:id="endnote-489"
                    label="566" audience="Computing">
                    <para audience="Computing" xml:id="para-idd_r4r_lr"><info>
                            <itermset>
                                <indexterm audience="Markup" zone="endnote-489">
                                    <primary>endnote</primary>
                                    <secondary>Computing</secondary>
                                </indexterm>
                                <indexterm zone="endnote-489">
                                    <primary>XML Information Set</primary>
                                    <secondary>contributions</secondary>
                                </indexterm>
                                <indexterm zone="endnote-489">
                                    <primary>default attribute values</primary>
                                </indexterm>
                                <indexterm zone="endnote-489">
                                    <primary>attribute</primary>
                                    <secondary>types</secondary>
                                </indexterm>
                                <indexterm zone="endnote-489">
                                    <primary>computing</primary>
                                    <secondary>XML Infoset contributions</secondary>
                                </indexterm>
                            </itermset>
                        </info>It should be noted that the content of the Infoset for a given
                        document may be affected by knowledge of any related <abbrev>DTD</abbrev>s
                        or schemas. That is to say that, upon examination of a given
                            <abbrev>XML</abbrev> document instance, its Infoset may be augmented
                        with some useful information, such as default attribute values and attribute
                        types. (See <xref linkend="sidebar_XML_Transclusion_Features"/>.)</para>
                </footnote></para>
            <para audience="Computing IA" xml:id="para-hgd_r4r_lr">As we discussed in <xref
                    linkend="sidebar_XML_Transclusion_Features"/>, <phrase role="statement"
                        ><abbrev>XML</abbrev> has the ability to describe graphs by incorporating
                    the use of ID and IDREF attribute types to create references among element
                    information items within the same document.</phrase> This modest form of
                hypertext linking allows us to present the following document fragment that
                approximates the graph we saw modeled in <xref linkend="figure-9-4"
                /></para>
            <example xml:id="example-9-8" label="9.8" audience="Computing IA">
                <title>XML implementation of a biblio-graph</title>

                <programlisting>
<literal>&lt;person id="WG.Sebald"&gt;Winfried George Sebald&lt;/person&gt;
&lt;person id="MR.McCulloch&gt;Mark Richard McCulloch&lt;/person&gt;

&lt;book&gt;
    &lt;title&gt;Understanding W.G. Sebald&lt;/title&gt;
    &lt;subject idref="WG.Sebald"/&gt;
    &lt;author idref="WG.Sebald"/&gt;
    &lt;author idref="MR.McCulloch"/&gt;
&lt;/book&gt;

&lt;book pages="371"&gt;
    &lt;title lang="de"&gt;Die Ringe des Saturne&lt;/title&gt;
    &lt;title lang="en"&gt;The Rings of Saturn&lt;/title&gt;
    &lt;author idref="WG.Sebald"/&gt;
&lt;/book&gt;

&lt;book pages="416"&gt;
    &lt;title lang="de"&gt;Austerlitz&lt;/title&gt;
    &lt;author idref="WG.Sebald"/&gt;
&lt;/book&gt;</literal>      </programlisting>
            </example>
            <para audience="CORE" xml:id="para-gjd_r4r_lr">As one might expect, tools and
                technologies in the document-processing world are optimized for manipulating and
                combining tree structures. A <quote>toolchain</quote> is set of tools intended to be
                used together to achieve some goal.</para>
            <sidebar xml:id="sidebar-XMLToolchain" audience="Computing IA">
                <title>The XML Toolchain</title>
                <?dbhtml sidebar-width="50%"?>
                <?dbhtml float-type="right"?>
                <info>
                    <itermset>
                        <indexterm zone="sidebar-XMLToolchain" condition="print" userlevel="Professional Graduate">
                            <primary>sidebar</primary>
                            <secondary>XML Toolchain</secondary>
                        </indexterm>
                        <indexterm zone="sidebar-XMLToolchain" condition="print" userlevel="Professional Graduate">
                            <primary>XML Toolchain</primary>
                        </indexterm>
                        <indexterm zone="sidebar-XMLToolchain">
                            <primary>XML</primary>
                            <secondary>toolchain</secondary>
                        </indexterm>
                        <indexterm zone="sidebar-XMLToolchain">
                            <primary>DTD</primary>
                        </indexterm>
                        <indexterm zone="sidebar-XMLToolchain">
                            <primary>RELAX-NG</primary>
                        </indexterm>
                        <indexterm zone="sidebar-XMLToolchain">
                            <primary>Schematron</primary>
                        </indexterm>
                        <indexterm zone="sidebar-XMLToolchain">
                            <primary>XProc</primary>
                        </indexterm>
                        <indexterm zone="sidebar-XMLToolchain">
                            <primary>XQuery</primary>
                        </indexterm>
                        <indexterm zone="sidebar-XMLToolchain">
                            <primary>XSLT</primary>
                        </indexterm>
                        <indexterm zone="sidebar-XMLToolchain">
                            <primary>XSD</primary>
                        </indexterm>
                    </itermset>
                </info>

                <para audience="CORE" xml:id="para-bmd_r4r_lr">The <abbrev>XML</abbrev> toolchain is
                    quite comprehensive. It consists of tools for creating <abbrev>XML</abbrev>
                    documents (XML editors), tools for expressing logical document and data models
                        (<abbrev>DTD</abbrev>, <citerefentry><refentrytitle>XML
                            Schema</refentrytitle></citerefentry>, <firstterm xml:id="first_RELAXNG"
                                ><citerefentry><refentrytitle>REgular LAnguage for XML Next
                                Generation</refentrytitle><manvolnum>RELAX
                            NG</manvolnum></citerefentry></firstterm>,
                            <citerefentry><refentrytitle>Schematron</refentrytitle></citerefentry>),
                    tools for transforming XML documents (<abbrev>XSLT</abbrev>), tools for
                    describing document processing <quote>pipelines</quote> (<firstterm
                        xml:id="first_XProc"><citerefentry><refentrytitle>XProc: An XML Pipeline
                                Language</refentrytitle></citerefentry></firstterm>), and tools for
                    storing and querying collections of <abbrev>XML</abbrev> documents
                        (<abbrev>XML</abbrev> databases, queried using
                            <citerefentry><refentrytitle>XML Query
                            Language</refentrytitle><manvolnum>XQuery</manvolnum></citerefentry>).
                    Used together, these tools provide very powerful means of working with
                    tree-structured documents. <abbrev>XML</abbrev> editors incorporate knowledge of
                        <abbrev>DTD</abbrev>s, schemas, transformations, style sheets, queries,
                    databases and pipelines. Pipelines choreograph the plumbing and
                    inter-dependencies involved in processing a complex dataset and publishing a
                    useful result in one or more output formats.</para>
            </sidebar>
            <para audience="CORE" xml:id="para-cpd_r4r_lr">For programmers who do not to use the
                    <abbrev>XML</abbrev> toolchain, other programming languages also provide
                libraries for working with <abbrev>XML</abbrev>. This fact has led some to propose,
                and others to believe, that <abbrev>XML</abbrev> is a kind of universal format for
                exchanging data among systems. However, programmers have observed that a random
                    <abbrev>XML</abbrev> Infoset does not map easily to the data structures commonly
                found in many programming languages. <quote>Working with
                    <abbrev>XML</abbrev></quote> frequently means translating from
                    <abbrev>XML</abbrev> tree structures to data structures native to another
                language, usually meaning lists and dictionaries. This translation can be
                problematic and often means giving up many of the strengths of <abbrev>XML</abbrev>.
                By the same token, there are decades more practical experience working with markup
                languages and institutional publishing than there is with <abbrev>JSON</abbrev> and
                    <abbrev>RDF</abbrev>.</para>
            <para audience="CORE" xml:id="para-csd_r4r_lr"><abbrev>XML</abbrev> is not a universal
                solution for every possible problem. That does not mean that it is not the best
                solution for a wide variety of problems, including yours. To gauge whether your
                resource descriptions are, or ought to be, part of the document-processing world,
                ask yourself the following questions:</para>
            <itemizedlist>
                <listitem>
                    <para audience="CORE" xml:id="para-evd_r4r_lr"><phrase role="interrogative">Do
                            my resource descriptions contain mixtures of narrative text, hypertext,
                            structured data and a variety of media formats?</phrase></para>
                </listitem>
                <listitem>
                    <para audience="CORE" xml:id="para-yxd_r4r_lr"><phrase role="interrogative">Can
                            my descriptions easily be modeled using tree structures, hypertext
                            links, and transclusion?</phrase></para>
                </listitem>
                <listitem>
                    <para audience="CORE" xml:id="para-v12_r4r_lr"><phrase role="interrogative">Are
                            the vocabularies I need or want to use made available using
                                <abbrev>XML</abbrev> technologies?</phrase></para>
                </listitem>
                <listitem>
                    <para audience="CORE" xml:id="para-wd2_r4r_lr"><phrase role="interrogative">Do I
                            need to work with a body of existing descriptions already encoded as
                                <abbrev>XML</abbrev>?</phrase></para>
                </listitem>
                <listitem>
                    <para audience="CORE" xml:id="para-wg2_r4r_lr"><phrase role="interrogative">Do I
                            need to interoperate with processes or partners that utilize the
                                <abbrev>XML</abbrev> toolchain?</phrase></para>
                </listitem>
                <listitem>
                    <para audience="CORE" xml:id="para-zj2_r4r_lr"><phrase role="interrogative">Do I
                            need to publish my resource descriptions in multiple formats from a
                            single source?</phrase></para>
                </listitem>
            </itemizedlist>
            <para audience="CORE" xml:id="para-ym2_r4r_lr">If the answer to one or more of these
                questions is <quote>yes,</quote> then chances are good that you are working within
                the document processing world, and you will need to become familiar with
                conceptualizing your descriptions as trees and working with them using
                    <abbrev>XML</abbrev> tools.</para>
        </section>
        <!--              -->
        <section xml:id="section-9.4.2" label="9.4.2">
            <title>The Web World</title>
            <info>
                <itermset>
                    <indexterm zone="section-9.4.2">
                        <primary>web world</primary>
                    </indexterm>
                    <indexterm zone="section-9.4.2">
                        <primary>resource description</primary>
                        <secondary>form</secondary>
                        <tertiary>HTML</tertiary>
                    </indexterm>
                    <indexterm zone="section-9.4.2">
                        <primary>resource description</primary>
                        <secondary>form</secondary>
                        <tertiary>dictionaries</tertiary>
                    </indexterm>
                    <indexterm zone="section-9.4.2">
                        <primary>URI</primary>
                    </indexterm>
                    <indexterm zone="section-9.4.2">
                        <primary>HTTP</primary>
                    </indexterm></itermset>
        </info>

            <para audience="CORE" xml:id="para-zp2_r4r_lr">The second <quote>world</quote> emerged
                in the early <date>1990s</date> with the creation of the World Wide Web. The web was
                developed to address a need for simple and rapid sharing of scientific data. Of
                course, it has grown far beyond that initial use case, and is now a ubiquitous
                infrastructure for all varieties of information and communication services.
                    (<quote>The browser world</quote> would be another appropriate name for what we
                are calling the Web World.)</para>
            <para audience="CORE" xml:id="para-ys2_r4r_lr"><phrase role="statement">Documents, data,
                    and services on the web are conceptualized as resources, identified using
                            <citerefentry><refentrytitle>Uniform Resource
                            Identifiers</refentrytitle><manvolnum>URI</manvolnum></citerefentry>,
                    and accessible through <emphasis>representations</emphasis> transferred via
                            <citerefentry><refentrytitle>Hypertext Transfer
                            Protocol</refentrytitle><manvolnum>HTTP</manvolnum></citerefentry>.</phrase>
                Representations are sequences of bytes, and could be <abbrev>HTML</abbrev> pages,
                    <abbrev>JPEG</abbrev> images, tabular data, or practically anything else
                transferable via <abbrev>HTTP</abbrev>. No matter what they are, representations
                transferred over the web include descriptions of themselves. These descriptions take
                the form of property-value pairs, known as <quote><abbrev>HTTP</abbrev>
                    headers.</quote>
                <phrase role="statement">The <abbrev>HTTP</abbrev> headers of web representations
                    are structured as dictionaries.</phrase></para>
            <para audience="CORE" xml:id="para-xv2_r4r_lr"><info><itermset>
                <indexterm zone="para-xv2_r4r_lr">
                <primary>constraints</primary>
                <secondary>temporal</secondary>
            </indexterm></itermset>
        </info>Dictionary structures appear many other
                places in web infrastructure. <abbrev>URI</abbrev>s may include a
                    <emphasis>query</emphasis> component beginning with a <literal>?</literal>
                character. This component is used for purposes such as providing query parameters to
                search services. The query component is commonly structured as a dictionary,
                consisting of a series of property-value pairs separated by the
                    <literal>&amp;</literal> character. For example, the following
                    <abbrev>URI</abbrev>: <programlisting xml:id="pro_id00006" linenumbering="unnumbered"><uri>https://www.google.com/search?q=sebald&amp;tbs=qdr:m</uri></programlisting>
                includes the query component <literal>q=sebald&amp;tbs=qdr:m</literal>.
                This is a dictionary with the properties <literal>q</literal> and
                    <literal>tbs</literal>, respectively specifying the search term and temporal
                constraints on the search.</para>

            <para audience="Web IA" xml:id="para-vy2_r4r_lr">Data entered into an
                    <abbrev>HTML</abbrev> form is also structured as a dictionary. When an
                    <abbrev>HTML</abbrev> form is submitted, the entered data is used either to
                compose the query component of a <abbrev>URI</abbrev>, or to create a new
                representation to be transferred to a web server. In either case, the data is
                structured as a set of properties and their corresponding values.</para>
            <para audience="Web IA" xml:id="para-wbf_r4r_lr"><phrase role="statement"
                        ><abbrev>HTML</abbrev> documents are structured as trees, but descriptions
                    embedded within <abbrev>HTML</abbrev> documents can also be structured as
                    dictionaries.</phrase>
                <abbrev>HTML</abbrev> documents may include a dictionary of metadata elements, each
                of which specifies a property and its value. Recently support for
                    <emphasis>microdata</emphasis> was added to <abbrev>HTML</abbrev>, which is
                another method of adding dictionaries of property-value pairs to documents. Using
                    <glossterm>microdata</glossterm>, authors can annotate web content with
                additional information, making it easier to automatically extract structured
                descriptions of that content.<footnote xml:id="endnote-490" label="567"
                    audience="Web">
                    <para audience="Web" xml:id="para-x2f_r4r_lr"><info>
                            <itermset>
                                <indexterm audience="Markup" zone="endnote-490">
                                    <primary>endnote</primary>
                                    <secondary>Web</secondary>
                                </indexterm>
                                <indexterm zone="endnote-490">
                                    <primary>Web</primary>
                                    <secondary>microdata</secondary>
                                </indexterm>
                                <indexterm zone="endnote-490">
                                    <primary>microdata</primary>
                                </indexterm>
                            </itermset>
                        </info>Microdata is an invention of WHATWG and exists and part of what they
                        call a <quote>living standard.</quote> It was supported by Google, so it was
                        widely used and there exist numerous controlled vocabularies, including
                        those for creative works, persons, events and organizations. Support for
                        microdata has since been withdrawn from Apple Safari and Google Chrome
                        browsers.</para>
                </footnote>
                <glossterm>Microformats</glossterm> are another method for doing this by mapping
                existing <abbrev>HTML</abbrev> attributes and values to (nested) dictionary
                    structures.<footnote xml:id="endnote-491" label="568" audience="Web">
                    <para audience="Web" xml:id="para-whf_r4r_lr"><info>
                            <itermset>
                                <indexterm audience="Markup" zone="endnote-491">
                                    <primary>endnote</primary>
                                    <secondary>Web</secondary>
                                </indexterm>
                                <indexterm zone="endnote-491">
                                    <primary>microformats</primary>
                                </indexterm>
                                <indexterm zone="endnote-491">
                                    <primary>Web</primary>
                                    <secondary>microformats</secondary>
                                </indexterm>
                            </itermset>
                        </info>Microformats is a non-standard that emerged from the community and
                        has been sponsored by CommerceNet and Microformats.org.</para>
                </footnote></para>
            <para audience="CORE" xml:id="para-ukf_r4r_lr"><phrase role="statement">Dictionary
                    structures are easy to work with in any programming language, and they pervade
                    various popular frameworks for programming the Web.</phrase> In the programming
                languages used to implement web services, <abbrev>HTTP</abbrev> headers and query
                parameters are easily mapped to dictionary data structures native to those
                languages. On the client side, there is only one programming language that runs
                within all web browsers:
                    <citerefentry><refentrytitle>JavaScript</refentrytitle></citerefentry>. The
                dictionary is the fundamental data structure within JavaScript as well.</para>
            <para audience="CORE" xml:id="para-xnf_r4r_lr">Thus it is unsurprising that
                    <abbrev>JSON</abbrev>, a dictionary-structured, JavaScript-based syntax, has
                become the <foreignphrase xml:lang="Latn">de facto</foreignphrase> standard for
                application-to-application interchange of data on the web in contexts that do not
                involve business transactions. Web services providing structured data intended for
                programmatic use can make that data available as <abbrev>JSON</abbrev>, which is
                well-suited for use either by JavaScript programs running within browsers, or by
                programs written in other languages running outside of browsers (e.g., smart phone
                applications).</para>
            <para audience="CORE" xml:id="para-zqf_r4r_lr">It is now commonly accepted that there
                are useful differences of approach between the document-processing world and the Web
                World. This does not mean that the two worlds do not have significant overlaps. Some
                very important web representation types are <abbrev>XML</abbrev>-based, such as the
                Atom syndication format. Trees will continue to be the structure of choice for web
                representations that consist primarily of narrative rather than transactional data.
                But for structured descriptions that are intended to be accessed and manipulated on
                the Web, dictionary structures currently rule.</para>
            <para audience="CORE" xml:id="para-b5f_r4r_lr">To gauge whether your resource
                descriptions are or ought to be part of the Web world, ask yourself the following
                questions:</para>
            <itemizedlist>
                <listitem>
                    <para audience="CORE" xml:id="para-fxf_r4r_lr"><phrase role="interrogative">Is
                            the web the primary platform upon which I will be making my descriptions
                            available?</phrase></para>
                </listitem>
                <listitem>
                    <para audience="CORE" xml:id="para-h1g_r4r_lr"><phrase role="interrogative">Are
                            my resource descriptions primarily structured, transaction-oriented
                            data?</phrase></para>
                </listitem>
                <listitem>
                    <para audience="CORE" xml:id="para-edg_r4r_lr"><phrase role="interrogative">Can
                            my descriptions easily be modeled as lists of properties and values
                            (dictionaries)?</phrase></para>
                </listitem>
                <listitem>
                    <para audience="CORE" xml:id="para-dgg_r4r_lr"><phrase role="interrogative">Are
                            the vocabularies I need or want to use made available primarily using
                                <abbrev>HTML</abbrev> technologies such as microdata or
                            microformats?</phrase></para>
                </listitem>
                <listitem>
                    <para audience="CORE" xml:id="para-gjg_r4r_lr"><phrase role="interrogative">Do I
                            need to make my descriptions easily usable for use within a wide array
                            of programming languages?</phrase></para>
                </listitem>
            </itemizedlist>
            <para audience="CORE" xml:id="para-fmg_r4r_lr">If the answer to one or more of these
                questions is <quote>yes,</quote> then chances are good that you are working within
                the Web World, and you will need to become familiar with conceptualizing your
                descriptions as dictionaries and working with them using programming languages such
                as JavaScript.</para>
        </section>
        <!--              -->
        <section xml:id="section-9.4.3" label="9.4.3">
            <title>The Semantic Web World</title>
            <info>
                <itermset>
                    <indexterm zone="section-9.4.3">
                        <primary>semantic</primary>
                        <secondary>web world</secondary>
                    </indexterm>
                    <indexterm zone="section-9.4.3">
                        <primary>resource description</primary>
                        <secondary>form</secondary>
                        <tertiary>triples</tertiary>
                    </indexterm></itermset>
        </info>

            <para audience="CORE" xml:id="para-epg_r4r_lr">The last world we consider is still
                somewhat of a possible world, at least in comparison with the previous two. While
                the document processing world and the web world are well-established, the Semantic
                Web world is only starting to emerge, despite having been envisioned over a decade
                ago.</para>
            <para audience="CORE" xml:id="para-esg_r4r_lr"><info><itermset>
                <indexterm zone="para-esg_r4r_lr">
                    <primary>constraints</primary>
                    <secondary>Semantic Web</secondary>
                </indexterm></itermset>
        </info><phrase role="definition" xml:id="def_semantic_web">The vision of a
                        <glossterm xml:id="term_semantic_web">Semantic Web</glossterm> world builds
                    upon the web world, but adds some further prescriptions and constraints for how
                    to structure descriptions. The Semantic Web world unifies the concept of a
                    resource as it has been developed in this book, with the web notion of a
                    resource as anything with a <abbrev>URI</abbrev>. On the Semantic Web, anything
                    being described must have a <abbrev>URI</abbrev>. Furthermore, the descriptions
                    must be structured as graphs, adhering to the <abbrev>RDF</abbrev> metamodel and
                    relating resources to one another via their <abbrev>URI</abbrev>s. Advocates of
                    Linked Data further prescribe that those descriptions must be made available as
                    representations transferred over <abbrev>HTTP</abbrev>.</phrase><footnote
                    xml:id="endnote-492" label="569" audience="Web">
                        <para audience="Web" xml:id="para-x5g_r4r_lr"><info><itermset>
                            <indexterm audience="Markup" zone="endnote-492"><primary>endnote</primary><secondary>Web</secondary></indexterm> </itermset></info><citation xml:id="cite_Bizer2009b"
                            linkend="Bizer2009b">(Bizer, Heath, and Berners-Lee
                        2009)</citation>.</para>
                </footnote></para>
            <para audience="CORE" xml:id="para-zxg_r4r_lr"><info>
                    <itermset>
                        <indexterm zone="para-zxg_r4r_lr">
                            <primary>Sebald, W.G.</primary>
                        </indexterm>
                    </itermset>
                </info>This is a departure from the web world. The web world is also structured
                around <abbrev>URI</abbrev>s, but it does not require that every resource being
                described have a <abbrev>URI</abbrev>. For example, in the web world a list of
                bibliographic descriptions of books by <personname><firstname>W.G.</firstname>
                    <surname>Sebald</surname></personname> might be published at a specific
                    <abbrev>URI</abbrev>, but the individual books themselves might not have
                    <abbrev>URI</abbrev>s. In the Semantic Web world, in addition to the list having
                a URIs, each book would have a <abbrev>URI</abbrev> too, in addition to whatever
                other identifiers it might have.<footnote xml:id="endnote-493" label="570"
                    audience="Web">
                    <para audience="Web" xml:id="para-cbh_r4r_lr"><info>
                            <itermset>
                                <indexterm audience="Markup" zone="endnote-493">
                                    <primary>endnote</primary>
                                    <secondary>Web</secondary>
                                </indexterm>
                                <indexterm zone="endnote-493">
                                    <primary>resolvability of URIs</primary>
                                </indexterm>
                                <indexterm zone="endnote-493">
                                    <primary>URI</primary>
                                    <secondary>resolvability</secondary>
                                </indexterm>
                                <indexterm zone="endnote-493">
                                    <primary>Web</primary>
                                    <secondary>URI resolvability</secondary>
                                </indexterm>
                            </itermset>
                        </info>It is worth noting that <abbrev>URI</abbrev>s are not required to
                        have anything at their endpoints. Resolvability of <abbrev>URI</abbrev>s is
                        evangelized as a best practice for Linked Data but not a requirement within
                        the broader Semantic Web paradigm. Merely asserting that a
                            <abbrev>URI</abbrev> is associated with a book is enough. If the
                            <abbrev>URI</abbrev> can return a description or a resource, so much the
                        better, but if not, at least you can talk about the book by referring to the
                        same <abbrev>URI</abbrev>.</para>
                </footnote></para>
            <para audience="CORE" xml:id="para-b2h_r4r_lr"><phrase role="statement principle">Making
                    an <abbrev>HTTP</abbrev> request to an individual book <abbrev>URI</abbrev> may
                    return a graph-structured description of that book, if best practices for Linked
                    Data are being followed.</phrase> This, too, is a departure from the web world,
                which is agnostic about the form representations or descriptions of resources should
                take (although as we have seen, dictionary structures are often favored on the web
                when the clients consuming those descriptions are computer programs). On the
                Semantic Web, all descriptions are structured as <abbrev>RDF</abbrev> graphs. Each
                description graph links to other description graphs by referring to these related
                resources using their <abbrev>URI</abbrev>s. Thus, at least in theory, all
                description graphs on the Semantic Web are linked into a single massive graph
                structure. In practice, however, it is far from clear that this is an achievable, or
                even a desirable, goal.</para>
            <para audience="CORE" xml:id="para-chh_r4r_lr"><info>
                    <itermset>
                        <indexterm zone="para-chh_r4r_lr">
                            <primary>VIAF</primary>
                        </indexterm>
                        <indexterm zone="para-chh_r4r_lr">
                            <primary>UK</primary>
                        </indexterm>
                        <indexterm zone="para-chh_r4r_lr">
                            <primary>DBpedia</primary>
                        </indexterm>
                    </itermset>
                </info>Although the Semantic Web is in its infancy, a significant number of resource
                descriptions have already been made available in accordance with the principles
                outlined above. Descriptions published according to these principles are often
                referred to as <quote>Linked Data.</quote> Prominent examples include: DBpedia, a
                graph of descriptions of subjects of Wikipedia articles; the <firstterm
                    xml:id="first_VIAF"><citerefentry xml:id="ref_VIAF"><refentrytitle>Virtual
                            International Authority
                        File</refentrytitle><manvolnum>VIAF</manvolnum></citerefentry></firstterm>,
                a graph of descriptions of names collected from various national
                    libraries<symbol>&#8217;</symbol> name authority files; GeoNames, a graph of
                descriptions of places; and Data.gov.uk, a graph of descriptions of public data made
                available by the UK government.<footnote xml:id="endnote-494" label="571"
                    audience="Web">
                    <para audience="Web" xml:id="para-fkh_r4r_lr"><info>
                            <itermset>
                                <indexterm audience="Markup" zone="endnote-494">
                                    <primary>endnote</primary>
                                    <secondary>Web</secondary>
                                </indexterm>
                                <indexterm zone="endnote-494">
                                    <primary>computing</primary>
                                    <secondary>linked data</secondary>
                                </indexterm>
                            </itermset>
                        </info>Many more available datasets are listed at <link
                            xmlns:xlink="http://www.w3.org/1999/xlink"
                            xlink:href="http://linkeddata.org/">linkeddata.org</link>.</para>
                </footnote></para>
            <para audience="CORE" xml:id="para-hnh_r4r_lr"><phrase role="statement">Despite the
                    growing amount of Linked Data, tools for working with graph-structured data are
                    still immature in comparison to the <abbrev>XML</abbrev> toolchain and Web
                    programming languages.</phrase> Although there is an <abbrev>XML</abbrev> syntax
                for <abbrev>RDF</abbrev>, using the <abbrev>XML</abbrev> toolchain to work with
                graph-structured data is generally a bad idea. And just as most programming
                languages do not support natively working with tree structures, most do not support
                natively working with graph structures either. Storing and querying graph-structured
                data efficiently requires a graph database or <emphasis>triple
                store</emphasis>.</para>
            <para audience="CORE" xml:id="para-kqh_r4r_lr">Still, the Semantic Web world has much to
                recommend it. Having a common way of identifying resources (the
                <abbrev>URI</abbrev>) and a single shared metamodel (<abbrev>RDF</abbrev>) for all
                resource descriptions makes it much easier to combine descriptions from different
                sources. To gauge whether your resource descriptions are or ought to be part of the
                Semantic Web world, ask yourself the following questions:</para>
            <itemizedlist>
                <listitem>
                    <para audience="CORE" xml:id="para-gth_r4r_lr"><phrase role="interrogative">Is
                            the web the primary platform upon which I will be making my descriptions
                            available?</phrase></para>
                </listitem>
                <listitem>
                    <para audience="CORE" xml:id="para-mwh_r4r_lr"><phrase role="interrogative">Is
                            it important that I be able to easily and freely aggregate the elements
                            of my descriptions in different ways and to combine them with
                            descriptions created by others?</phrase></para>
                </listitem>
                <listitem>
                    <para audience="CORE" xml:id="para-nzh_r4r_lr"><phrase role="interrogative">Are
                            my descriptions best modeled as graph structures?</phrase></para>
                </listitem>
                <listitem>
                    <para audience="CORE" xml:id="para-pc3_r4r_lr"><phrase role="interrogative">Have
                            the vocabularies I need or want to use been created using
                                <abbrev>RDF</abbrev>?</phrase></para>
                </listitem>
                <listitem>
                    <para audience="CORE" xml:id="para-pf3_r4r_lr"><phrase role="interrogative">Do I
                            need to work with a body of existing descriptions that have been
                            published as Linked Data?</phrase></para>
                </listitem>
            </itemizedlist>
            <para audience="CORE" xml:id="para-n33_r4r_lr">If the answer to one or more of these
                questions is <quote>yes,</quote> then chances are good that you should be working
                within the Semantic Web world, and you ought to become familiar with conceptualizing
                your descriptions as graphs and working with them using Semantic Web tools.</para>
            
        </section>
        
        
        <section userlevel="Editor" xml:id="section-9.4.4">
            <title>Where Worlds Meet</title>
            <para xml:id="para-ql3_r4r_lr">Recognizing that there is no single best solution, some
                practitioners are combining the three world views. This book, for example, is
                maintained as a set of XML documents, employing the DocBook 5 schema and an
                    <abbrev>XSLT</abbrev> transformation script to produce print,
                    <abbrev>XHTML</abbrev>, and ePub 3 formats for delivery to readers.</para>
            <note userlevel="Editor" xml:id="note-ch8-Editor-pyh_5bs_lr">
                <title>Editors' Note</title>
                <para xml:id="para-t43_r4r_lr">We can talk about mixing Document/Web/SemWeb as we
                    are doing with the book. It is not a winner takes all scenario. Everybody wins.
                    Such a section to serve as a summary/conclusion to the chapter.</para>
                <para xml:id="para-rr3_r4r_lr">Murray, add this.</para>
            </note>
        </section>
        
        <!-- ###################### SECTION ########################################### -->
    </section>
    <!--              -->
    <section xml:id="section-9.5" label="9.5">
        <title>Key Points in Chapter Nine</title>

        <qandaset role="quiz">
            <qandaentry>
                <question>
                    <para audience="CORE" role="interrogative">What are two
                        perspectives on forming resource descriptions?</para>
                </question>
                <answer>
                    <para audience="CORE">We can approach the problem of
                        how to form resource descriptions from two perspectives: structuring and
                        writing.</para>
                    <para audience="CORE" role="parenthetical">(See <xref
                            linkend="section-9.1"/>)</para>
                </answer>
            </qandaentry>
            <qandaentry audience="Computing">
                <question>
                    <para audience="CORE" role="interrogative">Are metamodels
                        domain-specific?</para>
                </question>
                <answer>
                    <para audience="CORE">Metamodels describe structures commonly found in resource
                        descriptions and other information resources, regardless of the specific
                        domain.</para>
                    <para audience="CORE" role="parenthetical">(See <xref linkend="section-9.2"
                        />)</para>
                </answer>
            </qandaentry>
            <qandaentry>
                <question>
                    <para audience="CORE" role="interrogative">What do
                        blobs, sets, lists, dictionaries, trees, and graphs have in common?</para>
                </question>
                <answer>
                    <para audience="CORE">Blobs, sets, lists, dictionaries,
                        trees, and graphs are all kinds of structures that can be used to form
                        resource descriptions.</para>
                    <para audience="CORE" role="parenthetical">(See <xref
                            linkend="section-9.2.1"/>)</para>
                </answer>
            </qandaentry>
            <qandaentry>
                <question>
                    <para audience="CORE" role="interrogative">What is a
                        list?</para>
                </question>
                <answer>
                    <para audience="CORE">A <emphasis>list</emphasis>, like
                        a set, is a collection of items with an additional constraint: their items
                        are <emphasis>ordered</emphasis>.</para>
                    <para audience="CORE" role="parenthetical">(See <xref
                            linkend="section-9.2.1.3"/>)</para>
                </answer>
            </qandaentry>
            <qandaentry>
                <question>
                    <para audience="CORE" role="interrogative">What is a
                        dictionary?</para>
                </question>
                <answer>
                    <para audience="CORE">A <glossterm
                            linkend="gloss_dictionary" xreflabel="dictionary"
                        >dictionary</glossterm>, also known as a <emphasis><glossterm
                                linkend="gloss_map">map</glossterm></emphasis> or an
                                <emphasis><glossterm linkend="gloss_associative_array">associative
                                array</glossterm></emphasis>, is a set of property-value pairs or
                            <emphasis>entries</emphasis>.</para>
                    <para audience="CORE" role="parenthetical">(See <xref
                            linkend="section-9.2.1.4"/>)</para>
                </answer>
            </qandaentry>
            <qandaentry>
                <question>
                    <para audience="CORE" role="interrogative">What is a
                        nested dictionary?</para>
                </question>
                <answer>
                    <para audience="CORE">Nested dictionaries form a
                            <glossterm linkend="gloss_tree">tree</glossterm>.</para>
                    <para audience="CORE" role="parenthetical">(See <xref
                            linkend="section-9.2.1.4"/>)</para>
                </answer>
            </qandaentry>
            <qandaentry>
                <question>
                    <para audience="CORE" role="interrogative">What is a
                        tree?</para>
                </question>
                <answer>
                    <para audience="CORE">Trees consist of <glossterm
                            linkend="gloss_node" xreflabel="nodes">nodes</glossterm> joined by
                            <glossterm linkend="gloss_edge">edges</glossterm>.</para>
                    <para audience="CORE" role="parenthetical">(See <xref
                            linkend="section-9.2.1.5"/>)</para>
                </answer>
            </qandaentry>
            <qandaentry audience="Computing">
                <question>
                    <para audience="CORE" role="interrogative">What are the two kinds of data
                        structures used by JSON?</para>
                </question>
                <answer>
                    <para audience="CORE"><abbrev>JSON</abbrev> consists of two kinds of structures:
                        lists (called <emphasis>arrays</emphasis> in JavaScript) and dictionaries
                        (called <emphasis>objects</emphasis> in JavaScript).</para>
                    <para audience="CORE" role="parenthetical">(See <xref linkend="section-9.2.2.1"
                        />)</para>
                </answer>
            </qandaentry>
            <qandaentry>
                <question>
                    <para audience="CORE" role="interrogative">What is the
                        XML Infoset?</para>
                </question>
                <answer>
                    <para audience="CORE">The <abbrev>XML</abbrev> Infoset
                        is a tree structure, where each node of the tree is defined to be an
                            <emphasis>information item</emphasis> of a particular type.</para>
                    <para audience="CORE" role="parenthetical">(See <xref
                            linkend="section-9.2.2.2"/>)</para>
                </answer>
            </qandaentry>
            <qandaentry>
                <question>
                    <para audience="CORE" role="interrogative">What is the
                        benefit of a data schema?</para>
                </question>
                <answer>
                    <para audience="CORE">Using schemas to define data
                        representation formats is a good practice that facilitates shared
                        understanding and contributes to long-term maintainability.</para>
                    <para audience="CORE" role="parenthetical">(See <xref
                            linkend="section-9.2.2.2"/>)</para>
                </answer>
            </qandaentry>
            <qandaentry audience="Computing">
                <question>
                    <para audience="CORE" role="interrogative">What is RDF?</para>
                </question>
                <answer>
                    <para audience="CORE">The <abbrev>RDF</abbrev> metamodel is a directed graph, so
                        it identifies one node (the one from which the edge is pointing) as the
                            <glossterm linkend="gloss_subject" xreflabel="subject"
                            >subject</glossterm> of the triple, and the other node (the one to which
                        the edge is pointing) as its <glossterm linkend="gloss_object"
                            xreflabel="object">object</glossterm>. The edge is referred to as the
                            <glossterm linkend="gloss_predicate" xreflabel="predicate"
                            >predicate</glossterm> or (as we have been saying)
                            <emphasis>property</emphasis> of the triple.</para>
                    <para audience="CORE" role="parenthetical">(See <xref linkend="section-9.2.2.3"
                        />)</para>
                </answer>
            </qandaentry>
            <qandaentry>
                <question>
                    <para audience="CORE" role="interrogative">What is an
                        encoding scheme?</para>
                </question>
                <answer>
                    <para audience="CORE">An <quote>encoding scheme</quote>
                        is a specialized writing system or syntax for particular types of values.
                        Encoding schemes specify how to <emphasis>textually represent</emphasis>
                        information.</para>
                    <para audience="CORE" role="parenthetical">(See <xref
                            linkend="section-9.3.1"/>)</para>
                </answer>
            </qandaentry>
            <qandaentry>
                <question>
                    <para audience="CORE" role="interrogative">What is a
                        writing system?</para>
                </question>
                <answer>
                    <para audience="CORE">A <glossterm
                            linkend="gloss_writing_system" xreflabel="writing system">writing
                            system</glossterm> employs notations, and adds a set of rules for using
                        them.</para>
                    <para audience="CORE" role="parenthetical">(See <xref
                            linkend="section-9.3.2"/>)</para>
                </answer>
            </qandaentry>
            <qandaentry>
                <question>
                    <para audience="CORE" role="interrogative">How could
                        one notation be used in multiple writing systems?</para>
                </question>
                <answer>
                    <para audience="CORE">Differences in ordering
                        demonstrate just one way that multiple writing systems may use the same
                        notation differently.</para>
                    <para audience="CORE" role="parenthetical">(See <xref
                            linkend="section-9.3.2"/>)</para>
                </answer>
            </qandaentry>
            <qandaentry>
                <question>
                    <para audience="CORE" role="interrogative">What is
                        syntax?</para>
                </question>
                <answer>
                    <para audience="CORE">Syntax is the rules that define
                        how characters can be combined into words and how words can be combined into
                        higher-level structures.</para>
                    <para audience="CORE" role="parenthetical">(See <xref
                            linkend="section-9.3.3"/>)</para>
                </answer>
            </qandaentry>
            <qandaentry>
                <question>
                    <para audience="CORE" role="interrogative">What are the
                        concerns of the document processing world?</para>
                </question>
                <answer>
                    <para audience="CORE">The document processing world is
                        concerned primarily with the creation, processing and management of hybrid
                        narrative-transactional documents.</para>
                    <para audience="CORE" role="parenthetical">(See <xref
                            linkend="section-9.4.1"/>)</para>
                </answer>
            </qandaentry>
            <qandaentry audience="Web">
                <question>
                    <para audience="CORE" role="interrogative">How are resources conceptualized in
                        the Web world?</para>
                </question>
                <answer>
                    <para audience="CORE">In the web world, documents, data, and services are
                        conceptualized as resources, identified using
                                <citerefentry><refentrytitle>Uniform Resource
                                Identifiers</refentrytitle><manvolnum>URI</manvolnum></citerefentry>,
                        and accessible through <emphasis>representations</emphasis> transferred via
                        the Hypertext Transfer Protocol (<abbrev>HTTP</abbrev>).</para>
                    <para audience="CORE" role="parenthetical">(See <xref linkend="section-9.4.2"
                        />)</para>
                </answer>
            </qandaentry>
            <qandaentry>
                <question>
                    <para audience="CORE" role="interrogative">What is a
                        resource in Semantic Web terms?</para>
                </question>
                <answer>
                    <para audience="CORE">The Semantic Web world unifies
                        the concept of a resource as it has been developed in this book, with the
                        web notion of a resource as anything with a <abbrev>URI</abbrev>.
                        Descriptions must be structured as graphs, adhering to the
                            <abbrev>RDF</abbrev> metamodel and relating <glossterm
                            linkend="gloss_resource">resources</glossterm> to one another via their
                            <abbrev>URI</abbrev>s.</para>
                    <para audience="CORE" role="parenthetical">(See <xref
                            linkend="section-9.4.3"/>)</para>
                </answer>
            </qandaentry>
        </qandaset>
    </section>
    
    <!-- ###################### CHAPTER ########################################### -->
</chapter>
